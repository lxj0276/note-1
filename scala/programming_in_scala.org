#+OPTIONS: ^:nil

[[http://www.scala-lang.org][scala 主网站]] 
[[http://booksites.artima.com/programming_in_scala][本书 p_ i_s]] :也可以下载到本书的源码
[[http://www.artima.com/forums/forum.jsp?forum=282][本书论坛]]
[[http://booksites.artima.com/programming_in_scala/errata][本书勘误表]]
* 可伸展的语言 
  给出了 scala 的设计，和它后面的理由，历史概要。
  了解 scala 的实际思想和背后的原因。
  是面向对象和函数式编程的组合。
** 增加新的类型
** 增加新的控制结构
   可以用基于 actor 的并发编程 API 来阐明：消息的发送和接受。
** 函数式编程
   函数式编程有两种指导理念：
   1. 函数是头等值
   2. 程序的操作应该把输入值映射为输出值而不是就地修改数据。即方法不应该有副作用。
      
* scala 的入门初探
  如何使用 scala 完成若干种基本变成任务，而不牵涉过多关于如何工作的细节。目的：着手敲击执行 scala 代码。
** 变量定义
   scala 有两种变量：val 和 var.
   val 类似与 java 中的 final 变量。var 类似与非 final 变量。
** 函数定义
   函数的每个参数必须带有前缀冒号的类型标注。
   当函数是递归的时候，函数结果类型必须明确的说明。
   如果函数仅包含一个语句，那么花括号也可以选择不写。
    def max(x: Int, y: Int): Int = {
     if (x > y) x
     else y
    }

    或者
    def max2(x: Int, y: Int) = if (x > y) x else y
** 用 foreach 和 for 做枚举
   字面量指直接写在代码里的常量值。
   args.foreach((arg: String) => println(arg))
   或 args.foreach(arg => println(arg))
   如果函数字面量只有一行语句并且只带一个参数那么指带参数也可以不写：
   args.foreach(println)

   函数字面量的语法构成包括： (x: Int, y: Int) => x + y 或 (arg: String) => println(arg)
   1. 括号及命名参数列表 (x: Int, y: Int)
   2. 右箭头 =>
   3. 函数体 x + y
* scala 的入门再探 next steps in scala
  更快上手 scala，能够开始在简单的脚本任务中使用 scala。

  scala 鼓励使用函数式风格。
  两种风格在代码上的区别：
  + 如果代码包含任何 var 变量，它可能是指令式风格
  + 如果代码不包含任何 var 变量，它可能是函数式风格
** scala 没有重载操作符
   +, -, *, /可以被用作方法名。
   1 + 2 对应的调用语句是：(1).+(2)
** array
  三个形式定义数组：
1. 
     #+BEGIN_SRC scala
    val greetStrings = new Array[String](3)
    greetStrings.update(0, "Hello")
    greetStrings.update(1, ", ")
    greetStrings.update(2, "world!\n")
    for (i <- 0.to(2))
      print(greetStrings.apply(i))
     #+END_SRC
2.
    #+BEGIN_SRC scala
    val numNames = Array("zero", "one", "two")
    #+END_SRC
3.
    #+BEGIN_SRC scala
    val numNames2 = Array.apply("zero", "one", "two")
    #+END_SRC  
** list
   在 scala 中::是右操作数：1 :: twoThree 对一 ing 的调用语句为 twoThree.::(1)

   #+BEGIN_SRC scala
     val twoThree = List(2, 3)
     val oneTwoThree = 1 :: twoThree
     println(oneTwoThree)

     >> List(1,2,3)
   #+END_SRC

list 有可变和不可变的

** tuples 元组
   list 只能存储单一的一种类型，tuple 可以存储不同的类型。
   可变不可变。

    #+BEGIN_SRC scala
    val pair = (99, "Luftballons")
    println(pair._1)
    println(pair._2)
    #+END_SRC

** set map
   scala.collection.mutable.Set
   scala.collection.immutable.HashSet

   #+BEGIN_SRC scala
     import scala.collection.mutable.Set
     val movieSet = Set("Hitch", "Poltergeist")
     movieSet += "Shrek"
     println(movieSet)
   #+END_SRC

   #+BEGIN_SRC scala
     import scala.collection.mutable.Map
     val treasureMap = Map[Int, String]()
     treasureMap += (1 -> "Go to island.")
     treasureMap += (2 -> "Find big X on ground.")
     treasureMap += (3 -> "Dig.")
     println(treasureMap(2))
   #+END_SRC

   #+BEGIN_SRC scala
     val romanNumeral = Map(
     1 -> "I", 2 -> "II", 3 -> "III", 4 -> "IV", 5 -> "V"
     )
     println(romanNumeral(4))
   #+END_SRC

** 简单读取文件

   #+BEGIN_SRC scala
     import scala.io.Source
     if (args.length > 0) {
     for (line <- Source.fromFile(args(0)).getLines())
     println(line.length +" "+ line)
     }
     else
     Console.err.println("Please enter filename")
   #+END_SRC

上一个输出变种，格式良好些：

#+BEGIN_SRC scala
  import scala.io.Source
  def widthOfLength(s: String) = s.length.toString.length
  if (args.length > 0) {
      val lines = Source.fromFile(args(0)).getLines().toList
      val longestLine = lines.reduceLeft(
          (a, b) => if (a.length > b.length) a else b
      )
      val maxWidth = widthOfLength(longestLine)
      for (line <- lines) {
      val numSpaces = maxWidth - widthOfLength(line)
      val padding = " " * numSpaces
      println(padding + line.length +" | "+ line)
      }
  }
  else
      Console.err.println("Please enter filename")
#+END_SRC

* 类和对象 classes and objects 
  描述面向对象语言的基本建设模块和如何编译运行 scala 程序教程开始有深度的覆盖 scala 语言。

** Classes, fields, and methods
   scala 类中属性，方法默认访问级别是 public

   #+BEGIN_SRC scala
    class ChecksumAccumulator {
        private var sum = 0
        def add(b: Byte): Unit = {
            sum += b
        }
        def checksum(): Int = {
          return ~ (sum & 0xFF) + 1
        }
    }
   #+END_SRC

   无论何时，当一个函数体前的等号去掉的时候，它的返回类型将被定义为 Unit. scala 编译器可以把任何类型转换为 Unit.
   #+BEGIN_SRC scala
     def add(b: Byte): Unit = sum += b
     和
     def add(b: Byte) { sum += b }
     表达的意思相同
   #+END_SRC

   #+BEGIN_SRC scala
     scala> def f(): Unit = "this String gets lost"
     f: ()Unit
   #+END_SRC

   当代码要在多行时可以用()扩起来，也可以把符号放在行尾，scala 通常的风格是把操作符放在行尾而不是行首。

   #+BEGIN_SRC scala
     (x
     + y)

     or 

     x +
     y +
     z
   #+END_SRC

** singleton object
   scala 没有静态成员。
   scala 定义单例类跟定义类的语法相似，只是关键字改为 object \\

   当单例对象和某个类共享同一个名字的时候，这个单例对象叫做类的 companion object.
   必须把类和类的 companion object 定义在同一个源文件中。这个源文件称为这个单例对象的 companion class。 \\

   可以把单例对象当作是 java 中可能会用到的静态方法工具类。可以用类似的方法调用。
   类和单例对象间的差别，单例对象不带参数，而类可以。因为单例对象不可 new。
   单例对象在第一次被访问的时候才初始化。

** scala application 的 main 方法

   scala 的每个源文件都隐含了对包 java.lang，包 scala 以及单例对象 Predef 的成员引用。

   #+BEGIN_SRC scala
    import ChecksumAccumulator.calculate

    object Summer {
        def main(args: Array[String]) {
          for (arg <- args)
          println(arg +": "+ calculate(arg))
        }
    }
   #+END_SRC

   编译 scala 源文件可以用两种方式：
   1. scalac
      scalac demo.scala demo2.scala
      每次都慢。
   2. fsc
      fsc  demo.scala demo2.scala
      fsc 会起一个后台进程，第一次慢，以后就快了。fsc -shutdown
   
** application 特质（trait）

   特质 scala.Application
   首先在单例对象名后面加上 extends Application.然后可以不用写 main 方法，直接把要执行的代码当在单例对象的花括号之间。

   trait 不能访问命令行参数，只有线程相对简单以及是单线程的情况下才可集成 Application 特质。

   #+BEGIN_SRC scala
     import ChecksumAccumulator.calculate

     object FallWinterSpringSummer extends Application {
         for (season <- List("fall", "winter", "spring"))
         println(season +": "+ calculate(season))
     }

   #+END_SRC

* 基本类型和操作
  基本类型，字面量，可执行的操作，优先级和关联性是如何工作的，副包装器。
  
** 基本类型
   除了 String 归于 java.lang 包，其余都是包 scala 的成员。

    *Byte* 8-bit signed two’s complement integer (-2 7 to 2 7 - 1, inclusive)
    *Short* 16-bit signed two’s complement integer (-2 15 to 2 15 - 1, inclusive)
    *Int* 32-bit signed two’s complement integer (-2 31 to 2 31 - 1, inclusive)
    *Long* 64-bit signed two’s complement integer (-2 63 to 2 63 - 1, inclusive)
    *Char* 16-bit unsigned Unicode character (0 to 2 16 - 1, inclusive)
    *String* a sequence of Char s
    *Float* 32-bit IEEE 754 single-precision float
    *Double* 64-bit IEEE 754 double-precision float
    *Boolean* true or false

** 字面量（literal)
   基本类型都可以写成字面量。字面量就是直接写在代码里的常量值。
   scala 的原字符串和符号字面量：
   + scala 为原始字符串引入了一种特殊的语法：三个引号(""")作为开始和结束，类似 python 中。
   + 符号字面量被写成 '<标识符>

     这里的标识符可以是任何字母或数字的标识符。这种字面量被映射成预定义类 scala.Symbol 实例。
     符号字面量除了显示名字之外，什么都不能做。

        #+BEGIN_SRC scala
           scala> def updateRecordByName(r: Symbol, value: Any) {
                 |   // code goes here
                 | }
            updateRecordByName: (Symbol,Any)Unit


           scala> val s = 'aSymbol
            s: Symbol = 'aSymbol

            scala> s.name
            res20: String = aSymbol
        #+END_SRC

** 操作符和方法
   操作符实际只是普通方法调用的另一种表现形式。
   任何方法都可以是操作符。
   中缀操作符， 前缀操作符， 后缀操作符。其中前，后缀操作符都是一元(unary)的。

   #+BEGIN_SRC scala
     scala> val sum = 1 + 2    // Scala invokes (1).+(2)
       sum: Int = 3
     scala> val sumMore = (1).+(2) 
       sumMore: Int = 3

     scala> s indexOf 'o'     // Scala invokes s.indexOf('o')
       res0: Int = 4

     scala> -2.0                  // Scala invokes (2.0).unary_-
       res2: Double = -2.0

       scala> (2.0).unary_-
       res3: Double = -2.0

     scala> s.toLowerCase 
      res4: java.lang.String = hello, world!
     scala> s toLowerCase
      res5: java.lang.String = hello, world!

   #+END_SRC

** 对象相等性
   比较两个对象是否相等，可以用==，或者！=

   + scala 的==和 java 中的区别 ::
     java 中对于引用类型，==比较引用相等性，scala 的==比较值的相等性。
     scala 比较引用相等性的机制为 eq,ne.
     scala 如何编写好的 equals 方法。

* 函数式对象
  面向对象的更深层次，使用函数式（即不可变）有理数作为例子。
  + 类参数和构造参数
  + 方法和操作符 ::
    
  + 私有成员 :: val numer: Int = n
  + 重写 
  + 先决条件检查 require(flat: Boolean)
  + 重载
  + 自引用 :: this
  + 辅助构造器 :: 
    主构造器是类的唯一入口点。scala 中的每个辅助构造器的地一个动作都是调用同类的别的构造器，so 辅助构造器都是以 this(...) 形式开头，最后终结于对主构造器的调用。
  + scala 中的 constant :: Pi 等的常量。scala 的常量习惯写法为第一个字母必须大写，驼峰式风格。
  + 隐式转换 :: 
    当把下一行加入到解释器中时表示将 int 隐式转换为 Rational 对象：
    implicit def intToRational(x: Int) = new Rational(x);
    如果要让隐式转换起作用，需要定义在作用范围之内。

  scala 把类内部任何即不是字段也不是方法定义的代码编译至主构造器中。
  不可变对象，必须确保对象创建时数据的有效性。先决条件判断的两种方式：
  + 使用 require 方法 :: 
    方法带一个布尔型参数，如果值为 false，require 将抛出 IllegalArgumentException 阻止对象被构造
 
  操作符名称来创建方法并定义隐式转换能帮助设计出让客户代码更简洁和易于理解的库。如果无技巧的使用，也会让客户代码变得难以阅读和理解。
  代码要可读，易懂，简洁。

  字母数字标示符 java 和 scala 不相同的地方在于常量的定义。java 使用全大写下划线分割，scala 只要求第一个字母必须大写（然后驼峰规则最好）。
  例如：MAX_VALUE， 在 scala 中 MaxValue
  #+BEGIN_SRC scala
    class Rational(n: Int, d: Int) {
        require(d != 0)
        override def toString = n +"/"+ d
      }
  #+END_SRC

  #+BEGIN_SRC scala
    class Rational(n: Int, d: Int) {

      require(d != 0)

      private val g = gcd(n.abs, d.abs)
      val numer = n / g
      val denom = d / g

      def this(n: Int) = this(n, 1)

      def + (that: Rational): Rational =
        new Rational(
          numer * that.denom + that.numer * denom,
          denom * that.denom
        )

      def + (i: Int): Rational =
        new Rational(numer + i * denom, denom)

      def - (that: Rational): Rational =
        new Rational(
          numer * that.denom - that.numer * denom,
          denom * that.denom
        )

      def - (i: Int): Rational =
        new Rational(numer - i * denom, denom)

      def * (that: Rational): Rational =
        new Rational(numer * that.numer, denom * that.denom)

      def * (i: Int): Rational =
        new Rational(numer * i, denom)

      def / (that: Rational): Rational =
        new Rational(numer * that.denom, denom * that.numer)

      def / (i: Int): Rational =
        new Rational(numer, denom * i)

      override def toString = numer +"/"+ denom

      private def gcd(a: Int, b: Int): Int = 
        if (b == 0) a else gcd(b, a % b)
    }

    object Main {
      def main(args: Array[String]) {
        val x = new Rational(2, 3)
        println("x [" + x + "]")
        println("x * x [" + (x * x) + "]")
        println("x * 2 [" + (x * 2) + "]")

        implicit def intToRational(x: Int) = new Rational(x)
        val r = new Rational(2,3)
        println("2 * r [" + (2 * r) + "]")
      }
    }
  #+END_SRC

* 内建控制结构
  if,while,for,try,match 及函数调用。
** if
   使用 val，能让代码即容易阅读又容易重构。
   val 的好处：
   + 代码变量不变 :: 节省审查变量作用域的所有代码，以及检查它是否改变的工作。
   + 支持等效推论（equational reasoning) :: 无论何时都可以用表达式代替变量名。

    #+BEGIN_SRC scala
       var filename = "default.txt"
       if (!args.isEmpty)
          filename = args(0)

      改写为：
       val filename =
          if (!args.isEmpty) args(0)
          else "default.txt"
    #+END_SRC

** while
   通常情况下，要质疑对 wile 循环的使用，如果质疑对 var 的使用那样。
   while 循环不产生值，通常被纯函数式语言所舍弃，为了让程序发挥作用，while 循环通常不是更新 var 就是执行 I/O。
   如果用函数式风格编写，一般要用递归实现。

   递归的实现：默认的最大公约数函数 gcd loop 使用了 var 和 while 循环。
   下边的采用了递归而不需要 while 和 var.

   #+BEGIN_SRC scala
      def gcd(x: Long, y: Long): Long =  //返回最大公约数
         if (y == 0) x else gcd(y, x % y) 
   #+END_SRC

** for
   可以用来枚举集合类。
   可以在 for 中过滤和判断。
  
   #+BEGIN_SRC scala
     val filesHere = (new java.io.File("/home/kay")).listFiles
     for(file <- filesHere if file.getName.endsWith(".scala")) 
       println(file)

     for(i <- 1 to 4)
       println("Iteration " + i)

    for (
      file <- filesHere
      if file.isFile;
      if file.getName.endsWith(".scala")
    ) println(file)
   #+END_SRC

   嵌套枚举： 当加入多个 <- 字句的时候，就得到了嵌套的“循环”。

   #+BEGIN_SRC scala
     def fileLines(file: java.io.File) =
       scala.io.Source.fromFile(file).getLines.toList

     def grep(pattern: String) =
       for(
         file <- filesHere
         if file.getName.endsWith(".scala");
         line <- fileLines(file)
         trimmed = line.trim //把结果绑定到变量上，绑定的变量被当作 val 引入和使用，但不用带 val 关键字
         if trimmed.matchs(pattern)
       ) println(file + ": " + trimmed)

     grep(".*gcd.*")
   #+END_SRC

   用 yield 制造新集合: 只要在 for 表达式之前加上关键字 yield.
   语法：for {子句} yield {循环体}

   #+BEGIN_SRC scala
     def scalaFiles =
         for {
           file <- filesHere
           if file.getName.endsWith(".scala")
         } yield file
   #+END_SRC

** try
   scala 中 try-catch-finally 也产生值。由 finally 子句计算得到的值，即使有也会被抛弃，finally 之用于关闭文件等的清理工作。

   #+BEGIN_SRC scala
      import java.net.URL
       import java.net.MalformedURLException

       def urlFor(path: String) =
         try {
           new URL(path)
         } catch {
           case e: MalformedURLException =>
             new URL("http://www.scala-lang.org")
         }
   #+END_SRC

** match 表达式
   类似于 switch 语句。
   基本上 match 表达式可以用认识的模式（match）做选择。
   在 java 中 case 语句只能是整数类型和枚举常量。在 scala 中匹配表达式可以是任何类型的常量，都能当初 scala 里做比较用的 case.
   scala 中 break 是隐含的。并且 mactch 表达式也可以产生值。

   #+BEGIN_SRC scala
     val firstArg = if (!args.isEmpty) args(0) else ""

       val friend =
         firstArg match {
           case "salt" => "pepper"
           case "chips" => "salsa"
           case "eggs" => "bacon"
           case _ => "huh?"
         }

       println(friend)
   #+END_SRC

** 不再使用 break 和 continue
   用 if 代替 continue, 用布尔变量代替每个 break 是最简单的形式; 也可以把循环重写为递归函数(可以省略 var 变量)。

   #+BEGIN_SRC scala
       // java 的版本
       int i = 0;                // This is Java
       boolean foundIt = false;
       while (i < args.length) {
         if (args[i].startsWith("-")) {
           i = i + 1;
           continue;
         }
         if (args[i].endsWith(".scala")) {
           foundIt = true;
           break;
         }
         i = i + 1;
       }

       //用 if 和布尔判断代替 continue 和 break
       var i = 0
       var foundIt = false

       while (i < args.length && !foundIt) {
         if (!args(i).startsWith("-")) {
           if (args(i).endsWith(".scala"))
             foundIt = true
         }
         i = i + 1
       }

     //写成递归函数，可以省略 var 变量
     def searchFrom(i: Int): Int =
         if (i >= args.length) -1
         else if (args(i).startsWith("-")) searchFrom(i + 1) 
         else if (args(i).endsWith(".scala")) i
         else searchFrom(i + 1)

       val i = searchFrom(0)
   #+END_SRC

** 用函数式风格重构指令式风格的乘法表

   #+BEGIN_SRC scala
      // Returns a row as a sequence
       def makeRowSeq(row: Int) =
         for (col <- 1 to 10) yield {
           val prod = (row * col).toString
           val padding = " " * (4 - prod.length)
           padding + prod
         }

       // Returns a row as a string
       def makeRow(row: Int) = makeRowSeq(row).mkString

       // Returns table as a string with one row per line
       def multiTable() = {

         val tableSeq = // a sequence of row strings
           for (row <- 1 to 10)
           yield makeRow(row)

         tableSeq.mkString("\n")
       }
   #+END_SRC

* 函数和闭包
  函数式语言的基础建设模块，函数。
  把大程序分割成小的片段。
  scala 提供了很多 java 中没有的定义函数的方式：
  + 作为对象成员的函数
  + 内嵌在函数中的函数
  + 函数字面量和函数值

** 本地函数
   像定义本地变量一样可以把函数定义在别的函数内部。
   本地函数能够访问包含其函数的参数。
   嵌套和作用域原则可以应用于所有的 scala 架构，包括函数。

   #+BEGIN_SRC scala
      import scala.io.Source

       object LongLines {

         def processFile(filename: String, width: Int) {

           def processLine(line: String) {
             if (line.length > width)
               print(filename +": "+ line)
           }    

           val source = Source.fromFile(filename)
           for (line <- source.getLines)
             processLine(line)
         }
       }
   #+END_SRC

** 头等函数
   不仅可以定义和调用函数，还可以把他们写成匿名的字面量（literal),并把他们作为值传递。
   函数字面量和值的区别在于字面量存在于源代码，而函数值作为对象存在于运行期;类似于类（源代码）和对象（运行期）的区别
   (x: Int) => x + 1  //这个函数可以把任意的 x 映射为 x+1.

   #+BEGIN_SRC scala
     var increase = (x: Int) => x + 1
     increase(10)
   #+END_SRC

   函数字面量可以包含多条语句，用花括号包住，组成代码块;函数的返回值是最后一行表达式产生的值。

** 字面量的短格式
   + 去除参数类型
   + 去除无用字符

     #+BEGIN_SRC scala
       val someNumbers = List(-11, -10, -5, 0, 5, 10)
       someNumbers.filter((x) => x > 0)

       // 短格式
       someNumbers.filter(x => x > 0)
     #+END_SRC

** 占位符语法 _
   可以把下划线当作一个或者更多参数的占位符。
   多个下划线指待多个参数。

   #+BEGIN_SRC scala
      someNumbers.filter(x => x > 0)

     // 占位符
     someNumbers.filter(_ > 0)
   #+END_SRC

** 部分应用函数
   部分应用函数是一种表达式，不需要提供函数的所有参数，只需要提供部分或者不提供参数，取而代之用 “_”。
   foreach 需要一个函数作为参数输入

   #+BEGIN_SRC scala
     def sum(a: Int, b: Int, c: Int) = a + b + c
     val a = sum _
     a(1, 2, 3)
   #+END_SRC

** 闭包 closure
    函数字面量在运行时创建的函数值(对象)被成为闭包（需要包含自由变量）。
    不带自由变量的函数字面量成为封闭项（closed term).

    #+BEGIN_SRC scala
      (x: Int) => x + 1  //closed term

      (x: Int) => x + more  // 闭包
    #+END_SRC
    任何以(x: Int) => x + more 为模板在运行期创建的函数值将必须捕获对自由变量 more 的绑定。

    java 的内部类不允许访问外围范围内可以改变的变量。
    闭包在运行期改变的自由变量值，仍然在闭包之外可见。

    #+BEGIN_SRC scala
      //创建和返回“递增”闭包的函数
      def makeIncreaser(more: Int) = (x: Int) => x + more

      val inc2 = makeIncreaser(2)
      inc2(4)  //output 6
    #+END_SRC

** 重复参数
   允许向函数传入可变长度参数列表: 在参数类型之后放一个星号。

   #+BEGIN_SRC scala
     def echo(args: String*) = 
       for (arg <- args) println(arg)

     echo("hello", "world")
   #+END_SRC

** 尾递归
   最后一个动作调用自己的函数，成为尾递归。
   尾递归函数将不会为每个调用开辟新的堆栈结构，所有的调用将在一个结构内执行。
   scala 编译器会优化尾递归。

   函数调用应尽量被实现为优化的尾调用。

   #+BEGIN_SRC scala
     def approximate(guess: Double): Double = 
         if (isGoodEnough(guess)) guess
         else approximate(improve(guess))
   #+END_SRC

* 控制抽象
  自定义控制抽象来增强 scala 的基本控制结构，柯里化和传名参数。

  用高阶函数去重复所有程序源代码中常见的控制模式，使用 currying 和传名参数使高阶函数简洁。
  函数分为通用部分（函数体）和非通用部分(参数)
** 高阶函数
   高阶函数的好处：减少代码重复；简化客户端代码编写。
   1. 通过创造控制抽象，从而减少代码重复

      #+BEGIN_SRC scala
        object Files1 {
          object FileMatcher {
            private def filesHere = (new java.io.File(".")).listFiles
          
            def filesEnding(query: String) =
              for (file <- filesHere; if file.getName.endsWith(query))
                yield file

            def filesContaining(query: String) =
              for (file <- filesHere; if file.getName.contains(query))
                yield file

            def filesRegex(query: String) =
              for (file <- filesHere; if file.getName.matches(query))
                yield file
          }

          def main(args: Array[String]) {
            println("FileMatcher.filesEnding(\"scala\").toList [" +
                    FileMatcher.filesEnding("scala").toList + "]")
            println("FileMatcher.filesContaining(\"Files1\").toList [" + 
                    FileMatcher.filesContaining("Files1").toList + "]")
            println("FileMatcher.filesRegex(\".*Re.ex.*\").toList [" + 
                    FileMatcher.filesRegex(".*Re.ex.*").toList + "]")
          }
        }
      #+END_SRC

      在 scala 中不允许在运行期粘合代码，所以下边的定义不对。不能把方法名当作值传递。
      #+BEGIN_SRC scala
        // 不正确 不允许 粘合 method.  file.getName.method(query) 
        def fileMatching(query: String, method) = 
          for(file <- filesHere; if file.getName.method(query)) 
            yield file
      #+END_SRC

      + 第一次重构 :: 
        虽然不能把方法名当作值传递，但是可以通过传递调用方法的函数值达到同样的效果：添加一个 matcher 参数

                      #+BEGIN_SRC scala
                        object Files2 {
                          def filesHere = (new java.io.File(".")).listFiles

                          def filesMatching(query: String,
                              matcher: (String, String) => Boolean) = {

                            for (file <- filesHere; if matcher(file.getName, query))
                              yield file
                          }

                          def filesEnding(query: String) =
                            filesMatching(query, _.endsWith(_))

                          def filesContaining(query: String) =
                            filesMatching(query, _.contains(_))

                          def filesRegex(query: String) =
                            filesMatching(query, _.matches(_))

                          def main(args: Array[String]) {
                            println("filesEnding(\"scala\").toList [" +
                                    filesEnding("scala").toList + "]")
                            println("filesContaining(\"Files1\").toList [" + 
                                    filesContaining("Files1").toList + "]")
                            println("filesRegex(\".*Re.ex.*\").toList [" + 
                                    filesRegex(".*Re.ex.*").toList + "]")
                          }
                        }
                      #+END_SRC

      + 第二次重构 :: 用闭包减少参数传来传去的问题。

                      #+BEGIN_SRC scala
                        object Files {
                          object FileMatcher {
                            private def filesHere = (new java.io.File(".")).listFiles
                          
                            private def filesMatching(matcher: String => Boolean) =
                              for (file <- filesHere; if matcher(file.getName))
                                yield file
                          
                            def filesEnding(query: String) =
                              filesMatching(_.endsWith(query))
                          
                            def filesContaining(query: String) =
                              filesMatching(_.contains(query))
                          
                            def filesRegex(query: String) =
                              filesMatching(_.matches(query))
                          }

                          def main(args: Array[String]) {
                            println("FileMatcher.filesEnding(\"scala\").toList [" +
                                    FileMatcher.filesEnding("scala").toList + "]")
                            println("FileMatcher.filesContaining(\"Files1\").toList [" + 
                                    FileMatcher.filesContaining("Files1").toList + "]")
                            println("FileMatcher.filesRegex(\".*Re.ex.*\").toList [" + 
                                    FileMatcher.filesRegex(".*Re.ex.*").toList + "]")
                          }
                        }
                      #+END_SRC

   2. 简化客户代码 ::
      类似集合类型特定用途循环方法。
      exists 方法代表了控制抽象。

      #+BEGIN_SRC scala
        def containsOdd(nums: list[Int]) = nums.exists(_ % 2 == 1)
      #+END_SRC

** currying(柯里化)
   currying 的函数式编程技巧。

   #+BEGIN_SRC scala
     def plainOldSum(x: Int, y: Int) = x + y

     //currying 后
     def currentSum(x: Int)(y: Int) = x + y
   #+END_SRC

** 编写新的控制结构
   可以使用花括号代替小括号包围参数，但是，花括号的技巧仅在传入一个参数时有效。

   #+BEGIN_SRC scala
     import java.io._

     object WithPrintWriter2 {
       def withPrintWriter(file: File)(op: PrintWriter => Unit) {
         val writer = new PrintWriter(file)
         try {
           op(writer)
         } finally {
           writer.close()
         }
       }

       def main(args: Array[String]) {
         val file = new File("date.txt")
         
         withPrintWriter(file) {
           writer => writer.println(new java.util.Date)
         }
       }
     }
   #+END_SRC

   *by-name parameter(传名参数)*
   要实现一个 by-name parameter 就要让参数的类型开始于 "=>" 而不是 "() =>" 或者 "PrintWriter =>"等。

* 组合与继承
  scala 更多对面向对象的支持，实践中经常出现。
  In addition to these topics, we’ll discuss abstract classes, parameterless methods, extending classes, overriding methods and fields, parametric fields, invoking superclass constructors, polymorphism and dynamic binding, final members and classes, and factory objects and methods.

** 抽象类
   一个方法只要没有实现（即没有等号或者方法体），它就是抽象的。抽象方法的声明不需要抽象修饰符。

   #+BEGIN_SRC scala
     abstract class Element {
       def contents: Array[String]
     }
   #+END_SRC

** 定义无参数方法
   1. 无参数方法，在 scala 中非常普通: def height: Int
   2. 空括号方法，带有空括号的方法定义: def height(): Int
   统一访问原则(uniform access principle): 客户代码不应由属性是通过字段实现还是方法实现而受到影响。
   惯例：无论何时，只要方法没有参数，并且方法仅能通过读取所包含对象的属性去访问可变状态，就使用无参数方法。

   原则上，scala 的函数调用可以省略所有的空括号。然后，在调用的方法超出其调用者对象的属性时，推荐仍然写一对空括号。例如：如果方法执行了 I/O,或写入可重复赋值的变量（var），或读取不是调用者字段的 var，总之，无论是直接还是非直接使用可变对象，都应该添加空括号。

   scala 鼓励使用将不带参数且没有副作用的方法定义为无参数方法的风格。
   但是永远不要定义没有括号的带副作用的方法。

   如果调用的函数执行了操作就使用括号，如果仅提供对某个属性的访问，就省略分号。

   #+BEGIN_SRC scala
     "hello".length  // 没有副作用，所以无需()
     println()  // 最好别省略()
   #+END_SRC

** 扩展类
   继承（inheritance）表示超类的成员也是子类的成员。
   但以下两种情况例外：
   1. 超类的私有成员不能被子类继承。
   2. 子类重写超类成员的时候。
   子类型化(subtyping)：子类的值可以在任何需要其超类的值的地方使用。

   #+BEGIN_SRC scala
     class ArrayElement(conts: Array[String]) extends Element {
         def contents: Array[String] = conts
       }

     //  子类型化(subtyping)：子类的值可以在任何需要其超类的值的地方使用。
       scala> val ae = new ArrayElement(Array("hello", "world"))
       ae: ArrayElement = ArrayElement@d94e60
   #+END_SRC

   scala 和 java 的命名空间的不同：
   1. java 有四个命名空间（字段，方法，类型和包）
   2. scala 有两个命名空间 \\
      + 值（字段，方法，包，单例对象）
      + 类型（类和特质名）
   scala 把字段和方法放进统一个命名空间，所以可以实现使用 val 重写无参数方法（在 java 中无法做到）。

   #+BEGIN_SRC scala
      abstract class Element {
         def contents: Array[String]
       }

     // 改变 contents 的实现从一个方法变为一个字段
      class ArrayElement(conts: Array[String]) extends Element {
         val contents: Array[String] = conts
       }
   #+END_SRC

** 定义参数化字段
   类的参数同样可以使用 var 做前缀，这时字段可以被重新赋值。
   参数化字段也可以添加如 private, protected, override 这类的修饰符。

   #+BEGIN_SRC scala
      class Cat {
         val dangerous = false
       }

     // 定义参数化字段
       class Tiger(
         override val dangerous: Boolean,  // 字段名与超类相同
         private var age: Int
       ) extends Cat

     // 上边的定义是下边这种类定义方式的简写
       class Tiger(param1: Boolean, param2: Int) extends Cat {
         override val dangerous = param1
         private var age = param2
       }
   #+END_SRC

** 调用超类构造器
   当超类构造器需要带参数时，子类需要传给超类的主构造器一个参数; 要调用超类构造器，只要简单地把要传递的参数或参数列表放在超类名之后的括号里即可。

   #+BEGIN_SRC scala
      class LineElement(s: String) extends ArrayElement(Array(s)) {
         override def width = s.length
         override def height = 1
       }
   #+END_SRC

** override 修饰符
   scala 要求以下三点：
   1. 若子类成员重写了父类的具体成员时，则必须带有 override 修饰符；
   2. 若成员实现的是同名的抽象成员时，这个修饰符是可选的；
   3. 若成员并未重写或实现什么其他基类里的成员，则禁用这个修饰符。

** 定义 final 成员
   需要定义为 final 的情况：
   + 要确保一个成员不被子类重写
   + 要确保整个类不会有子类

** 其他
   ++操作符可以连接两个数组

   #+BEGIN_SRC scala
      def above(that: Element): Element =
         new ArrayElement(this.contents ++ that.contents)
   #+END_SRC

   #+BEGIN_SRC scala
       def beside(that: Element): Element = {
         val contents = new Array[String](this.contents.length)
         for (i <- 0 until this.contents.length)  //until 与 to 类似，只是不包含尾部：0 to (this.contents.length - 1)
           contents(i) = this.contents(i) + that.contents(i)
         new ArrayElement(contents)
       }

     // 可以简写为以下形式
     new ArrayElement(
         for (
           (line1, line2) <- this.contents zip that.contents
         ) yield line1 + line2
       )

     // zip 操作的含义
       Array(1, 2, 3) zip Array("a", "b") // result 为：Array((1, "a"), (2, "b"))
   #+END_SRC

** 定义工厂对象
   可以创建伴生对象，把它作为布局元素的工厂方法。

   #+BEGIN_SRC scala
      object Element {

         private class ArrayElement(
           val contents: Array[String]
         ) extends Element

         private class LineElement(s: String) extends Element {
           val contents = Array(s)
           override def width = s.length
           override def height = 1
         }

         private class UniformElement(
           ch: Char,
           override val width: Int,
           override val height: Int
         ) extends Element {
           private val line = ch.toString * width
           def contents = Array.make(height, line)
         }

         def elem(contents:  Array[String]): Element =
           new ArrayElement(contents)

         def elem(chr: Char, width: Int, height: Int): Element =
           new UniformElement(chr, width, height)

         def elem(line: String): Element =
           new LineElement(line)
       }

   #+END_SRC

* scala 的层级
  继承层级，以及 scala 的全体方法及底层类型
  在 scala 中，每个类都继承自 Any 的超类，在层级的低端还有两个通用的子类：Null 和 Nothing.
  Null is a subtype of all reference types; its only instance is the null reference. Since Null is not a subtype of value types, null is not a member of any such type. For instance, it is not possible to assign null to a variable of type scala.Int.
  Nothing is a subtype of every other type (including scala.Null); there exist no instances of this type.
  Any 有两个子类：AnyVal 和 AnyRef。
  AnyVal 是每个内建值类的父类。有 9 个内建值类：Byte, Short, Char, Int, Long, Float, Double, Boolean, Unit.
  Unit 对应于 java 中的 void,Unit 只有一个实例，写为().
  Int 可以隐式转换到 RichInt 上，方法 min,max,util,to,abs 等都定义在 scala.runtime.RichInt 上，所以 Int 也可以用。

  Nothing 的一个应用，在 scala 标准库中 Predef 对象有一个 error 方法，定义如下：

  #+BEGIN_SRC scala
     def error(message: String): Nothing =
        throw new RuntimeException(message)

     def divide(x: Int, y: Int): Int = 
        if (y != 0) x / y 
        else error("can't divide by zero")  // 因为 Nothing 是任意类的子类，所以可以把 Nothing 赋值给 Int，所以返回值仍为 Int
  #+END_SRC

* 特质(trait)
  演示在混入组成(mixin composition)中的机制。 演示特质如何工作，描述了通常的用法，解释为什么特质改善了传统的多继承。
  特质封装了方法和字段的定义，类可以混入任意多个特质。
  特质最常用的两个方式：
  1. 拓宽瘦接口为胖接口
  2. 定义可堆叠的改变。
  
  特质和其他语言中多重继承的区别？

** trait 的工作方式

    trait 的定义除了使用关键字 trait 之外，与类的定义无异。但是 trait 不能定义可变参数。
    trait 被定义之后，可以用 extends 或 with 关键字，把它混入到类中。
    如果想把特质混入显示扩展超类的类中，可以用 extends 指明待扩展的超类，用 with 混入特质。

    可以用特质的定义做任何类定义能做的事，除了以下两点不同之外语法也相同：
    1. 特质不能有任何“类”参数（传入给类的主构造器的参数）
    2. 在特质中，super 的调用是动态绑定的。而不论在哪里，类的 super 调用都是静态绑定的. \\
       特质中的 super 调用是线性的。
       class Cat extends Animal with Furry with Fourlegged  的调用顺序为： \\
       Cat, FourLegged, Furry, Animal, AnyRef, Any
       
       如果这些类和特质中任何一个通过 super 调用了方法，那么被调用的实现将是它线性化的右侧的一个实现。
       
    #+BEGIN_SRC scala
        trait Philosophical {
          def philosophize() {
            println("I consume memory, therefore I am!")
          }
        }
    #+END_SRC

    #+BEGIN_SRC scala
      class Animal

        class Frog extends Animal with Philosophical with Haslegs {
          override def toString = "green"
        }
    #+END_SRC

** Ordered 特质
   利用 ordered 特质定义<,>,<=,>=操作。Ordered 特质没有定义 equals 方法，需要自己定义。
   有两件事情要做：
   + 混入 Ordered 特质（需要在混入的时候设定类型参数）。
   + 定义 compare 方法来比较两个对象。

     #+BEGIN_SRC scala
        class Rational(n: Int, d: Int) extends Ordered[Rational] {
           // ...
           def compare(that: Rational) =
             (this.numer * that.denom) - (that.numer * this.denom)
         }

     #+END_SRC

** trait 用来做可堆叠的改变
   trait 可以改变类的方法。trait 是可堆叠的。
   trait 在声明为抽象的方法中可以有 super 调用，而这种调用 在普通的类中是非法的。因为 trait 的 super 调用是动态绑定的。
   super 调用在实现可堆叠改动的特质来说常用到，为了告诉编译器目的是什么，还必须对这种方法打上 abstract override 的标志，这种标志在类中也是非法的。
   trait 的混入次序是非常重要的，越靠近右侧的特质越先起作用。右侧特质的方法先被调用，如果这个方法调用了 super,他调用其左侧特质的方法。
   应时刻关注是否有机会以可堆叠的改变方式安排代码。

   #+BEGIN_SRC scala
       abstract class IntQueue {
         def get(): Int
         def put(x: Int)
       }

      trait Doubling extends IntQueue {
         abstract override def put(x: Int) { super.put(2 * x) }  // abstrat override . then super invoke
       }

       trait Incrementing extends IntQueue {
         abstract override def put(x: Int) { super.put(x + 1) }
       }

       trait Filtering extends IntQueue {
         abstract override def put(x: Int) {
           if (x >= 0) super.put(x)
         }
       }

       scala> val queue = (new BasicIntQueue
            |     with Incrementing with Filtering)  // 匿名类用两个 trait 堆叠修改方法。
       queue: BasicIntQueue with Incrementing with Filtering...

       scala> queue.put(-1); queue.put(0); queue.put(1)

       scala> queue.get()
       res15: Int = 1

       scala> queue.get()
       res16: Int = 2

   #+END_SRC

** 什么时候用 trait
   1. 如果行为不重复，做成具体类。
   2. 要在多个不相关的类中重用，做成 trait。只有 trait 可以混入到不同的类层级中。
   3. 如果希望从 java 代码中继承，就使用抽象类。
      
* 包和引用
  讨论大项目中的事物：顶层包，引用语句，访问控制修饰符(如 protected,private).
  减小耦合的方式之一：使用模块化风格编写代码；将程序分为若干小模块，把每块分为内部和外部。当必须改变模块的外部（即模块的接口）时，才需要和工作于其他模块的开发人员交互。
  使用对象的模块化编程比分割包更灵活。

** 包
   可以用两种方式把代码放在命名包中：
   + 通过 package 子句放在文件顶端的方式把整个文件内容放进包里。
   + 可以在 package 子句之后把要放到包中的定义用花括号括起来 :: 
     可以把类的测试与原始代码放在同一个文件，但在不同的包里。
        scala 在所有用户可创建的包之外提供了名为_root_的包，任何能写出来的顶层包都被当作_root_包的成员。
     
        #+BEGIN_SRC scala
          // first 
          package bobsrockets.navigation
            class Navigator

          // second
           package bobsrockets.navigation {

              // In package bobsrockets.navigation
              class Navigator

              package tests {

                // In package bobsrockets.navigation.tests
                class NavigatorSuite
              }
            }
        #+END_SRC

** 引用
   包和其他成员的引用用 import 子句。

   scala 的 import 语句和 java 的主要差异：
   + 在 scala 中引用可以出现在任何地方。
   + 可以指的是（单例或正统的）对象和包。
   + 可以重命名或隐藏一些被引用的成员。

   引用选择器可以包括以下模式：
   + 简单名 x。 :: 把 x 包含进引用名集。
   + 重命名子句 x => y ::  import java.sql.{Date => sDate}
   + 隐藏子句 x => _。 :: 把 x 排除在引用名集之外  import Fruits.{Pear => _, _}
   + 全包括 _ 。 :: 如果存在全包括，那么必须是引用选择的最后一个。
     
   scala 隐式为每个源文件添加三个引用：
   + import java.lang._
   + import scala._
   + import Predef._
     
   出现在靠后位置的引用将覆盖靠前的引用。
   
     #+BEGIN_SRC scala
        // easy access to Fruit
         import bobsdelights.Fruit

         // easy access to all members of bobsdelights
         import bobsdelights._

         // easy access to all members of Fruits
         import bobsdelights.Fruits._

         // 重命名 Apple 为 McIntosh
         import Fruits.(Apple => McIntosh)

         //importFruits 下除了 Apple 的所有成员
         import Notebooks._
         import Fruits.{Apple => _, _}
     #+END_SRC

** 访问修饰符
   包，类和对象的成员可以用访问修饰符 private 和 protected 标记。没有标记的为公开的。
   标记为 private 的成员仅在包含了成员定义的类或者对象内部可见，内部类也应用同样的规则，外部类不能调用内部类的 private 引用。
   protected 保护成员只能在类和类的子类中被访问，在同一包中的其他类也不能访问。

   #+BEGIN_SRC scala
      class Outer {
         class Inner {
           private def f() { println("f") }
           class InnerMost {
             f() // OK
           }
         }
         (new Inner).f() // error: f is not accessible
       }

       package p {
         class Super {
           protected def f() { println("f") }
         }
         class Sub extends Super {
           f()
         }
         class Other {
           (new Super).f()  // error: f is not accessible
         }
       }

   #+END_SRC

*** 保护的作用域
    scala 中访问修饰符可以通过使用限定词强调。
    如：private[x], protected[x] 表示直到 x 的私有或者保护；x 指待某个所属的包，类或单例对象。

    scala 还有一种比 private 更严格的访问修饰符 private[this].被它标记的仅能在包含了定义的同一个对象中被访问。

    #+BEGIN_SRC scala
      package bobsrockets {
         package navigation {
           private[bobsrockets] class Navigator { 
             protected[navigation] def useStarChart() {}
             class LegOfJourney {
               private[Navigator] val distance = 100
             }
             private[this] var speed = 200
           }
         }
         package launch {
           import navigation._
           object Vehicle { 
             private[launch] val guide = new Navigator
           }
         }
       }
    #+END_SRC

*** 可见性和伴生性
    scala 中代替静态成员的是，可以拥有包含成员的单例的伴生对象。
    类的所有访问权限都对伴生对象开放，反过来也如此。对象可以访问它的伴生类的私有成员。

* 断言和单元测试
  scala 的断言机制，各种可以为 scala 编写测试的工具。
  断言可以直接混合在生产代码中，也可以放在外部的单元测试中。
  不仅可以用 java 社区流行的测试工具：JUnit 和 TestNG；
  还可以用 scala 的测试工具：ScalaTest, ScalaCheck,specs。

** 断言
   assert, ensuring.
   assert 和 ensuring 可以使用 JVM 的-ea 和 -da 命令行标志开放和禁止。

   assert 可以带一个参数或者两个参数。
   ensuring 放发带一个函数做参数。

   #+BEGIN_SRC scala
       // assert
       def above(that: Element): Element = { 
         val this1 = this widen that.width 
         val that1 = that widen this.width 
         assert(this1.width == that1.width)
         elem(this1.contents ++ that1.contents) 
       }

       // ensuring
       private def widen(w: Int): Element =
         if (w <= width) 
           this 
         else { 
           val left = elem(' ', (w - width) / 2, height) 
           var right = elem(' ', w - width - left.width, height) 
           left beside this beside right 
         } ensuring (w <= _.width)
   #+END_SRC

** 单元测试
   JUnit, TestNG, ScalaTest, ScalaCheck, specs
*** ScalaTest
    简单扩展 org.scalatest.Suite 类
    Suite 代表一个测试集，测试方法名以 test 开头。可以直接在 scala 解释器中通过调用 execute 方法运行 Suite.

* 样本类和模式匹配
  是在编写正规的非封装的数据结构时用到的工具，尤其对树型递归数据很有用
** case class
  #+BEGIN_SRC scala
    abstract class Expr
      case class Var(name: String) extends Expr
      case class Number(num: Double) extends Expr
      case class UnOp(operator: String, arg: Expr) extends Expr
      case class BinOp(operator: String, 
          left: Expr, right: Expr) extends Expr
  #+END_SRC

  Using the "case" modifier makes the Scala compiler add some syntactic conveniences to your class.
  1. adds a factoy method with the name of class rather than use "new"

     #+BEGIN_SRC scala
       val v  = Var("x")
     #+END_SRC

     The factory methods are particularly nice when you nest them, because there are no noisy new keywords.

     #+BEGIN_SRC scala
       val op = BinOp("+", Number(1), v)
     #+END_SRC

  2. all arguments in the parameter list of a case class implicitly get a val prefix, so they are maintained as fields

     #+BEGIN_SRC scala
       v.name
       op.left
     #+END_SRC

  3. the compiler adds "natural" implementations of methods toString, hashcode and equals to your class.

  4. the compiler adds a copy method to your class for making modified copies.

     #+BEGIN_SRC scala
       val op = BinOp("+", Number(1), v)  // res1: BinOp = BinOp(+,Number(1.0),Var(x))
       op.copy(operator = "-")   // res2: BinOp = BinOp(-,Number(1.0),Var(x))
     #+END_SRC
** pattern matching

   #+BEGIN_SRC scala
     scala:
       selector match { alternatives }
     java:
       switch (selector) {alternatives}
   #+END_SRC

   #+BEGIN_SRC scala
     def simplifyTop(expr: Expr): Expr = expr match {
         case UnOp("-", UnOp("-", e))  => e   // Double negation
         case BinOp("+", e, Number(0)) => e   // Adding zero
         case BinOp("*", e, Number(1)) => e   // Multiplying by one
         case _ => expr
       }
   #+END_SRC
** Kinds of patterns
*** wildcard patterns

    #+BEGIN_SRC scala
      expr match {
          case BinOp(op, left, right) =>
            println(expr +" is a binary operation")
          case _ => println("It's something else")
        }

     expr match {
        case BinOp(_, _, _) => println(expr +"is a binary operation")
        case _ => println("It's something else")
      }
    #+END_SRC
*** constant patterns

    #+BEGIN_SRC scala
       def describe(x: Any) = x match {
          case 5 => "five"
          case true => "truth"
          case "hello" => "hi!"
          case Nil => "the empty list"
          case _ => "something else"
        }
    #+END_SRC
*** variable patterns

    #+BEGIN_SRC scala
       expr match {
          case 0 => "zero"
          case somethingElse => "not zero: "+ somethingElse
        }

      // Since pi is a variable pattern, so here compiler will not let you add a default case at all. 
       scala> E match {
             |   case pi => "strange math? Pi = "+ pi
             |   case _ => "OK"  
             | }
        <console>:9: error: unreachable code
                 case _ => "OK"  
                           ^
      // If you use a lowercase name for a pattern constant, enclose them with back ticks.
      scala> E match {
             |   case `pi` => "strange math? Pi = "+ pi
             |   case _ => "OK"
             | }
        res13: java.lang.String = OK
    #+END_SRC
*** Constructor patterns
The extra patterns mean that scala patterns support deep matches.
    #+BEGIN_SRC scala
      // checks the top-level object is a BinOp, and its third constructor parameter is Number, and that the value field of that number is 0
       expr match {
          case BinOp("+", e, Number(0)) => println("a deep match")
          case _ => 
        }
    #+END_SRC
*** Sequence patterns
    Can match against sequence types like List or Array just like you match agaist case classes.

    #+BEGIN_SRC scala
      // checks for a three-element list starting with zero
      expr match {
          case List(0, _, _) => println("found it")
          case _ =>
        }

      // match against a sequence without specifying how long it can be, can specify _* as the last element of pattern
       expr match {
          case List(0, _*) => println("found it")
          case _ =>
        }

    #+END_SRC
*** Tuple patterns

    #+BEGIN_SRC scala
       def tupleDemo(expr: Any) =
          expr match {
            case (a, b, c)  =>  println("matched "+ a + b + c)
            case _ =>
          }
    #+END_SRC
*** Typed patterns
    Can use a typed pattern as a convenient replacement for type tests and casts.

    #+BEGIN_SRC scala
      def generalSize(x: Any) = x match {
          case s: String => s.length
          case m: Map[_, _] => m.size
          case _ => -1
        }

    #+END_SRC
*** typed erasure
    The only exception to the erasure rule is arrays.
    Scala uses the erasure model of generics, just like java does.This means no information about type arguments is maintained at runtime.

    #+BEGIN_SRC scala
      // wrong
      scala>  def isIntIntMap(x: Any) = x match {
           |   case m: Map[Int, Int] => true
           |   case _ => false
           | }
        <console>:5: warning: non variable type-argument Int in
        type pattern is unchecked since it is eliminated by erasure
                 case m: Map[Int, Int] => true
                         ^
       scala> isIntIntMap(Map("abc" -> "abc"))
        res18: Boolean = true

      // Array can
      scala> def isStringArray(x: Any) = x match {
             |   case a: Array[String] => "yes"
             |   case _ => "no"
             | }
       isStringArray: (Any)java.lang.String

        scala> val as = Array("abc")
        as: Array[java.lang.String] = Array(abc)

        scala> isStringArray(as)
        res19: java.lang.String = yes

        scala> val ai = Array(1, 2, 3)
        ai: Array[Int] = Array(1, 2, 3)

        scala> isStringArray(ai)
        res20: java.lang.String = no

    #+END_SRC
*** variable binding
    Can simply write the variable name, then @, and then the pattern.
    The meaning of such a pattern is to perform the pattern match as normal, and if the pattern succeeds, set the variable to the matched object just as with a simple variable pattern.

    #+BEGIN_SRC scala
      expr match {
          case UnOp("abs", e @ UnOp("abs", _)) => e
          case _ =>
        }
    #+END_SRC
** pattern guards
   A pattern guards comes after a pattern and starts with an if.

   #+BEGIN_SRC scala
     // wrong
     scala> def simplifyAdd(e: Expr) = e match {
            |   case BinOp("+", x, x) => BinOp("*", x, Number(2))
            |   case _ => e
            | }
       <console>:10: error: x is already defined as value x
                case BinOp("+", x, x) => BinOp("*", x, Number(2))

     // right
      scala> def simplifyAdd(e: Expr) = e match {
            |   case BinOp("+", x, y) if x == y =>
            |     BinOp("*", x, Number(2))
            |   case _ => e
            | }
       simplifyAdd: (Expr)Expr

     // match only positive integers
       case n: Int if 0 < n => ...  

       // match only strings starting with the letter `a'
       case s: String if s(0) == 'a' => ... 
   #+END_SRC
** sealed classes
   A sealed class can not have any new subclasses added except the ones in the same file.

   Therefore, if you write a hierarchy of classes intended to be pattern matched, you should consider sealing them.

   #+BEGIN_SRC scala
      sealed abstract class Expr
       case class Var(name: String) extends Expr
       case class Number(num: Double) extends Expr
       case class UnOp(operator: String, arg: Expr) extends Expr
       case class BinOp(operator: String, 
           left: Expr, right: Expr) extends Expr


      def describe(e: Expr): String = e match {
         case Number(_) => "a number"
         case Var(_)    => "a variable"
       }
     warning: match is not exhaustive!
       missing combination           UnOp
       missing combination          BinOp

     // down here is ok
      def describe(e: Expr): String = e match {
         case Number(_) => "a number"
         case Var(_) => "a variable"
         case _ => throw new RuntimeException // Should not happen
       }

   #+END_SRC
** the Option type 
   Optional values are produced by some of the standard operations on Scala's collections.
   Such a value can be of two forms.It can be of the form Some(x) where x is the actual value. Or it can be the None object, which represents a missing value. 
  
* 使用列表
  最常用到的数据结构
** List literals
   The type of a list that has elements of type T is written List[T].

   #+BEGIN_SRC scala
     val fruit: List[String] = List("apples", "oranges", "pears")
     val nums: List[Int] = List(1, 2, 3, 4)
     val diag3: List[List[Int]] =
       List(
         List(1, 0, 0),
         List(0, 1, 0),
         List(0, 0, 1)
       )
     val empty: List[Nothing] = List()
   #+END_SRC

   The list type in scala is /covariant/. This means that  types S and T, if S is a subtype of T, then List[S] is a subtype of List[T].
** constructing lists
   All lists are built from two fundamental building blocks, Nil and ::(pronounced "cons").

   #+BEGIN_SRC scala
     val nums = 1 :: 2 :: 3 :: Nil
   #+END_SRC
** basic operations on lists
   All operations on lists can be expressed in terms of the following three:
   - head :: returns the first element
   - tail :: returns a list consisting of all elements except the first
   - isEmpty :: return ture if the list is empty.
     
   In scala, the insertion sort algorithm looks like:

   #+BEGIN_SRC scala
     def isort(xs: List[Int]): List[Int] =
       if (xs.isEmpty) Nil
       else insert(xs.head, isort(xs.tail))

     def insert(x: Int, xs: List[Int]): List[Int] =
       if (xs.isEmpty || x <= xs.head) x :: xs
       else xs.head :: insert(x, xs.tail)
   #+END_SRC
** list patterns

   #+BEGIN_SRC scala
     val fruit: List[String] = List("apples", "oranges", "pears")

     scala> val List(a, b, c) = fruit
     a: String = apples
     b: String = oranges
     c: String = pears

     scala> val a :: b :: rest = fruit
     a: String = apples
     b: String = oranges
     rest: List[String] = List(pears)

     def isort(xs: List[Int]): List[Int] = xs match {
       case List()   => List()
       case x :: xs1 => insert(x, isort(xs1))
     }

     def insert(x: Int, xs: List[Int]): List[Int] = xs match {
       case List()  => List(x)
       case y :: ys => if (x <= y) x :: xs
       else y :: insert(x, ys)
     }
   #+END_SRC

* 集合类型
  如何使用 scala 集合类型：列表，数组，元组集（tuple）及映射表
** Sequences
*** Lists
    fast addition and removal of items to the beginnig of the list but they do not provide fast access to arbitrary indexes.
*** Arrays
    allow to hold a sequence of elements and efficiently access an element at an arbitrary position, both to get or update the element.
*** List buffers
    Class list provides fast access to the head of the list, but not the end. Thus, when you need to build a list by appending to the end, you should consider building the list backwards by prepending elements to the front, then when down, calling reverse.

    Or another choice is ListBuffer. ListBuffer is a mutable object, which can help you build lists more efficiently when you need to append.
*** ArrayBuffers
    An ArrayBuffer is like an array, except that you can additionally add and remove elements from the beginning and end of the sequence.
*** Strings( via StringOps)
    StringOps implements many sequence methods.
    You can treat any string like a sequence, because Predef has an implicit conversion from String to StringOps.
** Sets and Maps
** selecting mutable versus immutable collection
   For small maps and sets, the immutable versions are much more compact than the mutable ones.
** initializing collections
   The most common way to create and initialize a collection is to pass the initial elements to a factory method on the companion object.

   #+BEGIN_SRC scala
     scala> List(1, 2, 3)
     res0: List[Int] = List(1, 2, 3)

     scala> Set('a', 'b', 'c')
     res1: scala.collection.immutable.Set[Char] = Set(a, b, c)

     scala> import scala.collection.mutable
     import scala.collection.mutable

     scala> mutable.Map("hi" -> 2, "there" -> 5)
     res2: scala.collection.mutable.Map[java.lang.String,Int] =
       Map(hi -> 2, there -> 5)

     scala> Array(1.0, 2.0, 3.0)
     res3: Array[Double] = Array(1.0, 2.0, 3.0)
   #+END_SRC

   #+BEGIN_SRC scala
     scala> import scala.collection.mutable
     import scala.collection.mutable

     scala> val stuff = mutable.Set(42)
     stuff: scala.collection.mutable.Set[Int] = Set(42)

     // the problem is that stuff was given an element type of Int
     scala> stuff += "abracadabra"
     <console>:7: error: type mismatch;
     found   : java.lang.String("abracadabra")
     required: Int
     stuff += "abracadabra"

     // resulve
     scala> val stuff = mutable.Set[Any](42)
     stuff: scala.collection.mutable.Set[Any] = Set(42)

   #+END_SRC

   #+BEGIN_SRC scala
     scala> val colors = List("blue", "yellow", "red", "green")
     colors: List[java.lang.String] =
       List(blue, yellow, red, green)

     scala> import scala.collection.immutable.TreeSet
     import scala.collection.immutable.TreeSet

     // cannot pass the colors list to the factory method for TreeSet
     scala> val treeSet = TreeSet(colors)
     <console>:6: error: no implicit argument matching
     parameter type (List[java.lang.String]) =>
     Ordered[List[java.lang.String]] was found.
     val treeSet = TreeSet(colors)

     // resulved
     scala> val treeSet = TreeSet[String]() ++ colors
     treeSet: scala.collection.immutable.SortedSet[String] =
       Set(blue, green, red, yellow)
   #+END_SRC
** converting between mutable and immutable sets and maps

   #+BEGIN_SRC scala
     scala> import scala.collection.mutable
     import scala.collection.mutable

     scala> treeSet
     res5: scala.collection.immutable.SortedSet[String] =
       Set(blue, green, red, yellow)

     scala> val mutaSet = mutable.Set.empty ++ treeSet
     mutaSet: scala.collection.mutable.Set[String] =
       Set(yellow, blue, red, green)

     scala> val immutaSet = Set.empty ++ mutaSet
     immutaSet: scala.collection.immutable.Set[String] =
       Set(yellow, blue, red, green)

    scala> val muta = mutable.Map("i" -> 1, "ii" -> 2)
    muta: scala.collection.mutable.Map[java.lang.String,Int] =
        Map(ii -> 2, i -> 1)

    scala> val immu = Map.empty ++ muta
    immu: scala.collection.immutable.Map[java.lang.String,Int] =
        Map(ii -> 2, i -> 1)

   #+END_SRC
** Tuples
   Tuples can combine objects of different types.
   A common application of tuples is returning multiple values from a method.
   Tuples are great when you combine data that has no meaning beyond "and A and B".
   However, whenever the combination has some meaning , or you want to and some mehod to the combination, it is better to go ahead and create a class.
* 有状态的对象 (stateful objects)
  什么是有状态（可变）的对象，scala 提供语法层面表达他们的术语。
  包括一个在离散事件模拟上的案例研究，用来演示一些有状态对象的动作
** what make an object stateful?
  For a stateful object, the result of a method call or field access may depend on what operations are previously performed on the object.

  #+BEGIN_SRC scala
    class BankAccount {

      private var bal: Int = 0

      def balance: Int = bal

      def deposit(amount: Int) {
        require(amount > 0)
        bal += amount
      }

      def withdraw(amount: Int): Boolean =
        if (amount > bal) false
        else {
          bal -= amount
          true
        }
    }
  #+END_SRC

  State and vars usually go hand in hand, but a class might be stateful without defining or inheriting any vars because it forwards method calls to other objects that have mutable state.
  在 scala 中字段不可以随意省略"=_"初始化器。如果：
   var celsius: Float = _ 写为 var celsius: Float，将定义为抽象变量，而不是未初始化的变量。
  #+BEGIN_SRC scala
     class Thermometer {

        var celsius: Float = _

        def fahrenheit = celsius * 9 / 5 + 32
        def fahrenheit_= (f: Float) {
          celsius = (f - 32) * 5 / 9
        }
        override def toString = fahrenheit +"F/"+ celsius +"C"
      }
  #+END_SRC
** reassignable variables and properties
   If it appears in a class, the var definition:
       var hour = 12
   generates a getter:"hour", and a setter:"hour_="

   #+BEGIN_SRC scala
     class Time {

       private[this] var h = 12
       private[this] var m = 12

       def hour: Int = h
       def hour_= (x: Int) {
         require(0 <= x && x < 24)
         h = x
       } 

       def minute = m
       def minute_= (x: Int) {
         require(0 <= x && x < 60)
         m = x
       }
     }
   #+END_SRC
   It is also possible and sometimes useful, to define a gette and a setter without an associated field.

   #+BEGIN_SRC scala
     class Thermometer {
       // you can set to a default value by specifing "_" as the "initializing value"
       var celsius: Float = _

       def fahrenheit = celsius * 9 / 5 + 32
       def fahrenheit_= (f: Float) {
         celsius = (f - 32) * 5 / 9
       }
       override def toString = fahrenheit +"F/"+ celsius +"C"
     }
   #+END_SRC

* 类型参数化(type parameterization)
  纯函数队列类的设计，以及一些信息隐藏技术。
  本章建立了关于各种类型参数的描述，以及它如何与信息隐藏实现交互。
  Type parameterization allows you to write generic classes and traits.
  For example, sets are generic and take a type parameter: Set[T].
  Unlike java, which allows raw types, scala requires that you specify type parameters.
  Set[String] is a subtype of Set[AnyRef].

** Functional queues

   #+BEGIN_SRC scala
     // first version 1.1
     class SlowAppendQueue[T](elems: List[T]) { // Not efficient
       def head = elems.head
       def tail = new SlowAppendQueue(elems.tail)
       def append(x: T) = new SlowAppendQueue(elems ::: List(x))
     }

     // first version 1.2
     class SlowHeadQueue[T](smele: List[T]) { // Not efficient
      // smele is elems reversed
      def head = smele.last
      def tail = new SlowHeadQueue(smele.init)
      def append(x: T) = new SlowHeadQueue(x :: smele)
     }
   #+END_SRC

   #+BEGIN_SRC scala
     // second version 
     class Queue[T](
       private val leading: List[T],
       private val trailing: List[T]
     ) {
       private def mirror =
         if (leading.isEmpty)
           new Queue(trailing.reverse, Nil)
         else
           this

       def head = mirror.leading.head

       def tail = {
         val q = mirror
         new Queue(q.leading.tail, q.trailing)
       }

       def append(x: T) =
         new Queue(leading, x :: trailing)
     }

   #+END_SRC

** Information hiding
*** private constructors and factory methods
    It is possible to hide the primary constructor by adding a private modifier in front of the class parameter list.

    #+BEGIN_SRC scala
      class Queue[T] private (
        private val leading: List[T],
        private val trailing: List[T]
      )

      scala> new Queue(List(1, 2), List(3))
      <console>:6: error: constructor Queue cannot be accessed in
      object $iw
      new Queue(List(1, 2), List(3))

      // one possibility way to add an auxiliary constructor, like:
      def this(elems: T*) = this(elems.toList, Nil)

      // another possibility way is to add a factory method that builds a queue from such a sequence of initial elements. like：
      Object Queue {
        def apply[T](xs: T*) = new Queue[T](xs.toList, Nil)
      }
   // Important note: 
      // make the object a companion object of the class.
      // Note that, because the factory method is called apply, clients can create queues with an expression such as Queue(1, 2, 3)
      // Using methods named apply inside global objects, you can support usage patterns  that look like invocations of global methods.
    #+END_SRC
*** an alternative: private classes
    One way to hide the initialization and representation of a calss is private constructors and private members.
    The other way, more radical, is to hide the class itself and only export a trait that reveals the public interface of the class.

    #+BEGIN_SRC scala
      trait Queue[T] {
        def head: T
        def tail: Queue[T]
        def append(x: T): Queue[T]
      }

      object Queue {

        def apply[T](xs: T*): Queue[T] =
          new QueueImpl[T](xs.toList, Nil)

        private class QueueImpl[T](
          private val leading: List[T],
          private val trailing: List[T]
        ) extends Queue[T] {

          def mirror =
            if (leading.isEmpty)
              new QueueImpl(trailing.reverse, Nil)
            else
              this

          def head: T = mirror.leading.head

          def tail: QueueImpl[T] = {
            val q = mirror
            new QueueImpl(q.leading.tail, q.trailing)
          }

          def append(x: T) =
            new QueueImpl(leading, x :: trailing)
        }
      }

    #+END_SRC

** 变化型注解(Variance annotations)
   In Scala, however, generic types have by default nonvariant (or, “rigid”) subtyping.
   However, you can demand covariant (flexible) subtyping of queues by changing the first line of the definition of class Queue like this:

   #+BEGIN_SRC scala
     trait Queue[+T] { ... }
   #+END_SRC
Besides + , there is also a prefix - , which indicates contravariant subtyping. If Queue were defined like this:

#+BEGIN_SRC scala
  // this means if T is a subtype of type S , this would imply that Queue[S] is a subtype of Queue[T]
  trait Queue[-T] { ... }
#+END_SRC


#+BEGIN_SRC scala
    class Cell[T](init: T) {
      private[this] var current = init
      def get = current
      def set(x: T) { current = x }
    }

  // Hava some error
  val c1 = new Cell[String]("abc")
  val c2: Cell[Any] = c1
  <console>:9: error: type mismatch;
   found   : Cell[String]
   required: Cell[Any]
  Note: String <: Any, but class Cell is invariant in type T.
  You may wish to define T as +T instead. (SLS 4.5)
         val c2: Cell[Any] = c1
                             ^
  // IT'S OK
  val c2: Cell[Any] = c1.asInstanceOf[Cell[Any]]
  c2: Cell[Any] = Cell@2437c6dc
#+END_SRC

   参数的变化型：协变（类型参数前的+）(covariant)，逆边（类型参数前的-）(contravariant)，非协变（类型参数前没有符号）(nonvariant)。
   + 非协变 ::
     trait Queue[T] {...}
   + 协变 :: 
     trait Queue[+T] {...}
     正常类型参数前+号表明这个参数的子类型化是协变（弹性）的。比如 String 是 AnyRef 的子类型，那么 Queue[String]将当作 Queue[AnyRed]的子类型。
   + 逆变 :: 
     trait Queue[-T] {...}
     -号表明参数的子类型化是逆变的,如果 T 是类型 S 的子类型，那么隐含 Queue[S]是 Queue[T]的子类型。
     
   超类型：语法"U >: T"，定义了 T 为 U 的下界。
   超类型和子类型的关系是自反的，亦类型对于自身来讲，既是超类型，也是子类型。

   #+BEGIN_SRC scala
     def append[U >: T](x: U) = new Queue[U] (leading, x :: trailing) 
     // ...
   #+END_SRC

   类型驱动设计。
   里氏替代原则(Liskov Substitution Principle, LSP): 如果能在需要类型 U 的值的地方替换成类型 T 的值，那么类型 T 是类型 U 的子类型的假设就是安全的。

* 抽象成员
  能够声明为抽象的有方法，字段，类型。
  In this chapter we'll describe all four kinds of abstract member: vals, vars, methods, and types.
  Along the way we'll discuss pre-initialized fields, lazy vals, path-dependent types, and enumerations.

  #+BEGIN_SRC scala
    trait Abstract {
      type T
      def transform(x: T): T
      val initial: T
      var current: T
    }


    class Concrete extends Abstract {
      type T = String
      def transform(x: String) = x + x
      val initial = "hi"
      var current = initial
    }
  #+END_SRC
** abstract vals

   #+BEGIN_SRC scala
     abstract class Fruit {val v: String // `v' for value
       def m: String // `m' for method
     }
     abstract class Apple extends Fruit {
       val v: String
       val m: String // OK to override a `def' with a `val'
     }
     abstract class BadApple extends Fruit {
       def v: String // ERROR: cannot override a `val' with a `def'
       def m: String
     }
   #+END_SRC
** abstrat vars

   #+BEGIN_SRC scala
     trait AbstractTime {
       var hour: Int
       var minute: Int
     }
   #+END_SRC
** Lazy vals
  Thus, lazy vals can free you as a programmer from having to think hard how to arrange val definitions to ensure that everything is defined when it is needed.
   #+BEGIN_SRC scala
     object Demo {
       val x = { println("initializing x"); "done" }
     }
         // scala> Demo
         // initializing x
         // res3: Demo.type = Demo$@2129a843
         // scala> Demo.x
         // res4: String = done
       // As you can see, the moment you use Demo, its x field becomes initialized. The initialization of xforms
       // part of the initialization of Demo. The situation changes, however, if you define the x field to be lazy:
     object Demo {
       lazy val x = { println("initializing x"); "done" }
     }
         // scala> Demo
         // res5: Demo.type = Demo$@5b1769c
         // scala> Demo.x
         // initializing x
         // res6: String = done
   #+END_SRC

   #+BEGIN_SRC scala
     trait LazyRationalTrait {
       val numerArg: Int
       val denomArg: Int
       lazy val numer = numerArg / g
       lazy val denom = denomArg / g
       override def toString = numer + "/" + denom
       private lazy val g = {
         require(denomArg != 0)
         gcd(numerArg, denomArg)
       }
       private def gcd(a: Int, b: Int): Int =
         if (b == 0) a else gcd(b, a % b)
     }
   #+END_SRC
** abstract types

   #+BEGIN_SRC scala
     class Food
     abstract class Animal {
       def eat(food: Food)
     }
     class Grass extends Food
     class Cow extends Animal {
       override def eat(food: Grass) = {} // This won't compile,
     }
       // but if it did,...
     class Fish extends Food

     val bessy: Animal = new Cow

     bessy eat (new Fish)
       // ...you could feed fish to cows.

     class Food
     abstract class Animal {
       type SuitableFood <: Food
       def eat(food: SuitableFood)
     }
   #+END_SRC
** enumerations
  Scala does not need special syntax for enumerations. Instead, there's a class in its standard library, scala.Enumeration.

  #+BEGIN_SRC scala
    object Color extends Enumeration {
      val Red = Value
      val Green = Value
      val Blue = Value
    }
  #+END_SRC

  #+BEGIN_SRC scala
    object Direction extends Enumeration {
      val North = Value("North")
      val East = Value("East")
      val South = Value("South")
      val West = Value("West")
    }
  #+END_SRC
** conclusion
  when designing a class, make everything that is not yet known into an abstract member. 
  It does not matter whether the unknown is a type, method, variable or value. In Scala, all of these
can be declared abstract.
* 隐式转换和参数
  这两个特性有助于程序员忽略掉源码中那些能由编译器推导出来的繁琐的细节的特性。
** implicit conversions  

   #+BEGIN_SRC scala
     val button = new JButton
     button.addActionListener(
       new ActionListener {
         def actionPerformed(event: ActionEvent) = {}
       )
         println("pressed!")
     }

     // then mismatch
     button.addActionListener( // Type mismatch!
       (_: ActionEvent) => println("pressed!")
     )

     // implicit
     implicit def function2ActionListener(f: ActionEvent => Unit) =
       new ActionListener {
         def actionPerformed(event: ActionEvent) = f(event)
       }

     // call directly
     button.addActionListener(
       function2ActionListener(
         (_: ActionEvent) => println("pressed!")
       )
     )

     // call implicit
     // Now this works
     button.addActionListener(
       (_: ActionEvent) => println("pressed!")
     )
   #+END_SRC
** RULES FOR IMPLICITS
  Marking rule: Only definitions marked implicit are available.

  #+BEGIN_SRC scala
    implicit def intToString(x: Int): String = ...
  #+END_SRC


  Scope rule: An inserted implicit conversion must be in scope as a single identifier, or be associated with the source or target type of the conversion.
  convert available as an implicit, you would need to import it, which would make it available as a single identifier. Once imported, the compiler would be free to apply it as convert(x) + y. In fact, it is common for libraries to include a Preamble object including a number of useful implicit conversions. Code that uses the library can then do a single "import Preamble._" to access the library's implicit conversions.

  One-at-a-time rule: Only one implicit is inserted.

  Explicits-first rule: Whenever code type checks as it is written, no implicits are attempted.

  There are three places implicits are used in the language: conversions to an expected type, conversions of the receiver of a selection, and implicit parameters.
  #+BEGIN_SRC scala
    object MyConversions {
      implicit def stringWrapper(s: String):
          IndexedSeq[Char] = ...
      implicit def intToString(x: Int): String = ...
    }

    import MyConversions.stringWrapper
      ... // code making use of stringWrapper
  #+END_SRC
** IMPLICIT PARAMETERS

   #+BEGIN_SRC scala
     object Greeter {
       def greet(name: String)(implicit prompt: PreferredPrompt) = {
         println("Welcome, " + name + ". The system is ready.")
         println(prompt.preference)
       }
     }
   #+END_SRC

   #+BEGIN_SRC scala
     def maxListOrdering[T](elements: List[T])
                        (ordering: Ordering[T]): T =
       elements match {
         case List() =>
           throw new IllegalArgumentException("empty list!")
         case List(x) => x
         case x :: rest =>
           val maxRest = maxListOrdering(rest)(ordering)
           if (ordering.gt(x, maxRest)) x
           else maxRest
     }
   #+END_SRC

   #+BEGIN_SRC scala
     def maxList[T](elements: List[T])
                (implicit ordering: Ordering[T]): T =
       elements match {
         case List() =>
           throw new IllegalArgumentException("empty list!")
         case List(x) => x
         case x :: rest =>
           val maxRest = maxList(rest)
             // (ordering) is implicit
           if (ordering.gt(x, maxRest)) x // this ordering is
           else maxRest
             // still explicit
     }
   #+END_SRC

   #+BEGIN_SRC scala
     def maxList[T](elements: List[T])
                (implicit ordering: Ordering[T]): T =
       elements match {
         case List() =>
           throw new IllegalArgumentException("empty list!")
         case List(x) => x
         case x :: rest =>
           val maxRest = maxList(rest)
             // (ordering) is implicit
           if (ordering.gt(x, maxRest)) x // this ordering is
           else maxRest
             // still explicit
     }
   #+END_SRC




* 实现列表
  描述 list 类的实现。实现本身也展示了若干 scala 特性的应用。

* 重访 for 表达式
  解释 for 表达式如何翻译成对 map,flatMap,filter,foreach 的访问。

* Extractors(抽取器)
  展示了如何使用模式匹配任何类，而不仅仅是用例类。

* 注解
  通过注解使用语言的扩展部分。示范若干标准注解以及建立自己的注解

* 使用 XML
  处理 XML。包括创建，解析以及解析之后处理等一系列惯用方式。

* 使用对象的模块化编程
  说明消除了分离式模块系统的使用需求。

* 对象相等性
  指出若干在编写 equals 方法时要考虑的情况。
  说明了若干应避免的误区。

* 结合 scala 和 java
  在同一项目中捆绑使用 java 和 scala 时会碰到的状况，以及建议的解决方法。

* actor 和并发
  如何使用 actor 并发库。
  尽管使用 java 平台的同步原语和来自与 scala 程序的库，但 actor 能帮助避免死锁和资源竞争这些传统的并发问题。

* 连接符解析(跳过了）
  演示如何使用 scala 的解析器连接符来创建解析器。

* GUI 编程
  简化基于 swing 的 GUI 编程。

* SCells 试算表
  通过一个完整的试算表的实现，集中演示了 scala 的一切。

* Exception(异常)
It’s important to note that Scala’s philosophy regarding checked exceptions is different than Java’s. Scala doesn’t require that methods declare that exceptions can be thrown, and it also doesn’t require calling methods to catch them. 
  #+BEGIN_SRC scala
    import java.io._
    object CopyBytes extends App {
      var in = None: Option[FileInputStream] var out = None: Option[FileOutputStream]
      try {
        in = Some(new FileInputStream("/tmp/Test.class"))
        out = Some(new FileOutputStream("/tmp/Test.class.copy")) var c = 0
        while ({c = in.get.read; c != −1}) {
          out.get.write(c)
        }
      } catch {
        case e: IOException => e.printStackTrace
      } finally {
        println("entered finally ...") if (in.isDefined) in.get.close if (out.isDefined) out.get.close
      } }
  #+END_SRC

  #+BEGIN_SRC scala
    @throws(classOf[IOException]) @throws(classOf[LineUnavailableException]) @throws(classOf[UnsupportedAudioFileException]) def playSoundFileWithJavaAudio {
      // exception throwing code here ...
    }
  #+END_SRC


* FQA
  1. case 类的用法，模式
  2. scala 符号字面量的用法及作用。
