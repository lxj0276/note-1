#+OPTIONS: ^:nil

[[http://www.scala-lang.org][scala主网站]] 
[[http://booksites.artima.com/programming_in_scala][本书p_ i_s]] :也可以下载到本书的源码
[[http://www.artima.com/forums/forum.jsp?forum=282][本书论坛]]
[[http://booksites.artima.com/programming_in_scala/errata][本书勘误表]]
* 可伸展的语言 
  给出了scala的设计，和它后面的理由，历史概要。
  了解scala的实际思想和背后的原因。
  是面向对象和函数式编程的组合。
** 增加新的类型
** 增加新的控制结构
   可以用基于actor的并发编程API来阐明：消息的发送和接受。
** 函数式编程
   函数式变成有两种指导理念：
   1. 函数是头等值
   2. 程序的操作应该把输入值映射为输出值而不是就地修改数据。即方法不应该有副作用。
      
* scala的入门初探
  如何使用scala完成若干种基本变成任务，而不牵涉过多关于如何工作的细节。目的：着手敲击执行scala代码。
** 变量定义
   scala有两种变量：val和var.
   val类似与java中e的final变量。var类似与非final变量。
** 函数定义
   函数的每个参数必须带有前缀冒号的类型标注。
   当函数是递归的时候，函数结果类型必须明确的说明。
   如果函数仅包含一个语句，那么花括号也可以选择不写。
    def max(x: Int, y: Int): Int = {
     if (x > y) x
     else y
    }

    或者
    def max2(x: Int, y: Int) = if (x > y) x else y
** 用foreach和for做枚举
   字面量指直接写在代码里的常量值。
   args.foreach((arg: String) => println(arg))
   或 args.foreach(arg => println(arg))
   如果函数字面量只有一行语句并且只带一个参数那么指带参数也可以不写：
   args.foreach(println)

   函数字面量的语法构成包括： (x: Int, y: Int) => x + y 或 (arg: String) => println(arg)
   1. 括号及命名参数列表 (x: Int, y: Int)
   2. 右箭头 =>
   3. 函数体 x + y
* scala的入门再探 next steps in scala
  更快上手scala，能够开始在简单的脚本任务中使用scala。

  scala鼓励使用函数式风格。
  两种风格在代码上的区别：
  + 如果代码包含任何var变量，它可能是指令式风格
  + 如果代码不包含任何val变量，它可能是函数式风格
** scala没有重载操作符
   +, -, *, /可以被用作方法名。
   1 + 2对应的调用语句是：(1).+(2)
** array
  三个形式定义数组：
1. 
     #+BEGIN_SRC scala
    val greetStrings = new Array[String](3)
    greetStrings.update(0, "Hello")
    greetStrings.update(1, ", ")
    greetStrings.update(2, "world!\n")
    for (i <- 0.to(2))
      print(greetStrings.apply(i))
     #+END_SRC
2.
    #+BEGIN_SRC scala
    val numNames = Array("zero", "one", "two")
    #+END_SRC
3.
    #+BEGIN_SRC scala
    val numNames2 = Array.apply("zero", "one", "two")
    #+END_SRC  
** list
   在scala中::是右操作数：1 :: twoThree对一ing的调用语句为twoThree.::(1)

   #+BEGIN_SRC scala
     val twoThree = List(2, 3)
     val oneTwoThree = 1 :: twoThree
     println(oneTwoThree)

     >> List(1,2,3)
   #+END_SRC

list有可变和不可变的

** tuples元组
   list只能存储单一的一种类型，tuple可以存储不同的类型。
   可变不可变。

    #+BEGIN_SRC scala
    val pair = (99, "Luftballons")
    println(pair._1)
    println(pair._2)
    #+END_SRC

** set map
   scala.collection.mutable.Set
   scala.collection.immutable.HashSet

   #+BEGIN_SRC scala
     import scala.collection.mutable.Set
     val movieSet = Set("Hitch", "Poltergeist")
     movieSet += "Shrek"
     println(movieSet)
   #+END_SRC

   #+BEGIN_SRC scala
     import scala.collection.mutable.Map
     val treasureMap = Map[Int, String]()
     treasureMap += (1 -> "Go to island.")
     treasureMap += (2 -> "Find big X on ground.")
     treasureMap += (3 -> "Dig.")
     println(treasureMap(2))
   #+END_SRC

   #+BEGIN_SRC scala
     val romanNumeral = Map(
     1 -> "I", 2 -> "II", 3 -> "III", 4 -> "IV", 5 -> "V"
     )
     println(romanNumeral(4))
   #+END_SRC

** 简单读取文件

   #+BEGIN_SRC scala
     import scala.io.Source
     if (args.length > 0) {
     for (line <- Source.fromFile(args(0)).getLines())
     println(line.length +" "+ line)
     }
     else
     Console.err.println("Please enter filename")
   #+END_SRC

上一个输出变种，格式良好些：

#+BEGIN_SRC scala
  import scala.io.Source
  def widthOfLength(s: String) = s.length.toString.length
  if (args.length > 0) {
  val lines = Source.fromFile(args(0)).getLines().toList
  val longestLine = lines.reduceLeft(
  (a, b) => if (a.length > b.length) a else b
  )
  val maxWidth = widthOfLength(longestLine)
  for (line <- lines) {
  val numSpaces = maxWidth - widthOfLength(line)
  val padding = " " * numSpaces
  println(padding + line.length +" | "+ line)
  }
  }
  else
  Console.err.println("Please enter filename")
#+END_SRC

* 类和对象 classes and objects 
  描述面向对象语言的基本建设模块和如何编译运行scala程序教程开始有深度的覆盖scala语言。

** Classes, fields, and methods
   scala类中属性，方法默认访问级别是public

   #+BEGIN_SRC scala
    class ChecksumAccumulator {
        private var sum = 0
        def add(b: Byte): Unit = {
            sum += b
        }
        def checksum(): Int = {
          return ~ (sum & 0xFF) + 1
        }
    }
   #+END_SRC

   无论何时，当一个函数体前的等号去掉的时候，它的返回类型将被定义为Unit. scala编译器可以把任何类型转换为Unit.
   #+BEGIN_SRC scala
     def add(b: Byte): Unit = sum += b
     和
     def add(b: Byte) { sum += b }
     表达的意思相同
   #+END_SRC

   #+BEGIN_SRC scala
     scala> def f(): Unit = "this String gets lost"
     f: ()Unit
   #+END_SRC

   当代码要在多行时可以用()扩起来，也可以用+符号做后缀。

   #+BEGIN_SRC scala
     (x
     + y)

     or 

     x +
     y +
     z
   #+END_SRC

** singleton object
   scala没有静态成员。
   scala定义单例类跟定义类的语法相似，只是关键字改为object \\

   当单例对象和某个类共享同一个名字的时候，这个单例对象叫做类的companion object.
   必须把类和类的companion object 定义在同一个源文件中。这个源文件称为这个单例对象的companion class 。 \\

   可以把单例对象当作是java中可能会用到的静态方法工具类。可以用类似的方法调用。
   类和单例对象间的差别，单例对象不带参数，而类可以。因为单例对象不可new。
   单例对象在第一次被访问的时候才初始化。

** scala application 的 main 方法

   scala的每个源文件都隐含了对包java.lang，包scala以及单例对象Predef的成员引用。

   #+BEGIN_SRC scala
    import ChecksumAccumulator.calculate

    object Summer {
        def main(args: Array[String]) {
          for (arg <- args)
          println(arg +": "+ calculate(arg))
        }
    }
   #+END_SRC

   编译scala源文件可以用两种方式：
   1. scalac
      scalac demo.scala demo2.scala
      每次都慢。
   2. fsc
      fsc  demo.scala demo2.scala
      fsc会起一个后台进程，第一次慢，以后就快了。fsc -shutdown
   
** application 特质（trait）

   特质scala.Application
   首先在单例对象名后面加上 extends Application.然后可以不用写main方法，直接把要执行的代码当在单例对象的花括号之间。

   trait 不能访问命令行参数，只有线程相对简单以及是单线程的情况下才可集成Application特质。

   #+BEGIN_SRC scala
     import ChecksumAccumulator.calculate

     object FallWinterSpringSummer extends Application {
         for (season <- List("fall", "winter", "spring"))
         println(season +": "+ calculate(season))
     }

   #+END_SRC

* 基本类型和操作
  基本类型，字面量，可执行的操作，优先级和关联性是如何工作的，副包装器。
  
** 基本类型
   除了String归于java.lang包，其余都是包scala的成员。

    *Byte* 8-bit signed two’s complement integer (-2 7 to 2 7 - 1, inclusive)
    *Short* 16-bit signed two’s complement integer (-2 15 to 2 15 - 1, inclusive)
    *Int* 32-bit signed two’s complement integer (-2 31 to 2 31 - 1, inclusive)
    *Long* 64-bit signed two’s complement integer (-2 63 to 2 63 - 1, inclusive)
    *Char* 16-bit unsigned Unicode character (0 to 2 16 - 1, inclusive)
    *String* a sequence of Char s
    *Float* 32-bit IEEE 754 single-precision float
    *Double* 64-bit IEEE 754 double-precision float
    *Boolean* true or false

** 字面量（literal)
   基本类型都可以写成字面量。字面量就是直接写在代码里的常量值。
   scala的原字符串和符号字面量：
   + scala为原始字符串引入了一种特殊的语法：三个引号(""")作为开始和结束，类似python中。
   + 符号字面量被写成 '<标识符> ::
     这里的标识符可以是任何字母或数字哦的标识符。这种字面量被映射成预定义类scala.Symbol实例。
     符号字面量除了显示名字之外，什么都不能做。

        #+BEGIN_SRC scala
           scala> def updateRecordByName(r: Symbol, value: Any) {
                 |   // code goes here
                 | }
            updateRecordByName: (Symbol,Any)Unit


           scala> val s = 'aSymbol
            s: Symbol = 'aSymbol

            scala> s.name
            res20: String = aSymbol
        #+END_SRC

** 操作符和方法
   操作符实际只是普通方法调用的另一种表现形式。
   任何方法都可以是操作符。
   中缀操作符， 前缀操作符， 后缀操作符。其中前，后缀操作符都是一元(unary)的。

   #+BEGIN_SRC scala
     scala> val sum = 1 + 2    // Scala invokes (1).+(2)
       sum: Int = 3
     scala> val sumMore = (1).+(2) 
       sumMore: Int = 3

     scala> s indexOf 'o'     // Scala invokes s.indexOf('o')
       res0: Int = 4

     scala> -2.0                  // Scala invokes (2.0).unary_-
       res2: Double = -2.0

       scala> (2.0).unary_-
       res3: Double = -2.0

     scala> s.toLowerCase 
      res4: java.lang.String = hello, world!
     scala> s toLowerCase
      res5: java.lang.String = hello, world!

   #+END_SRC

** 对象相等性
   比较两个对象是否相等，可以用==，或者！=

   + scala的==和java中的区别 ::
     java中对于引用类型，==比较引用相等性，scala的==比较值的相等性。
     scala比较引用相等性的机制为eq,ne.
     scala如何编写好的equals方法。

* 函数式对象
  面向对象的更深层次，使用函数式（即不可变）有理数作为例子。
  + 类参数和构造参数
  + 方法和操作符
  + 私有成员 :: val numer: Int = n
  + 重写 
  + 先决条件检查 require(flat: Boolean)
  + 重载
  + 自引用 :: this
  + 辅助构造器 :: 
    主构造器是类的唯一入口点。scala中的每个辅助构造器的地一个动作都是调用同类的别的构造器，so辅助构造器都是以 this(...) 形式开头，最后终结于对主构造器的调用。
  + scala中的constant :: Pi等的常量。scala的常量习惯写法为第一个字母必须大写，驼峰式风格。
  + 隐式转换 :: 
    当把下一行加入到解释器中时表示将int隐式转换为Rational对象：
    implicit def intToRational(x: Int) = new Rational(x);
    如果要让隐式转换起作用，需要定义在作用范围之内。

  scala把类内部任何即不是字段也不是方法定义的代码编译至主构造器中。
  不可变对象，必须确保对象创建时数据的有效性。先决条件判断的两种方式：
  + 使用require方法 :: 
    方法带一个布尔型参数，如果值为false，require将抛出IllegalArgumentException阻止对象被构造
  + 

  操作符名称来创建方法并定义隐式转换能帮助设计出让客户代码更简洁和易于理解的库。如果无技巧的使用，也会让客户代码变得难以阅读和理解。
  代码要可读，易懂，简洁。
  
  #+BEGIN_SRC scala
    class Rational(n: Int, d: Int) {
        require(d != 0)
        override def toString = n +"/"+ d
      }
  #+END_SRC

  #+BEGIN_SRC scala
    class Rational(n: Int, d: Int) {

      require(d != 0)

      private val g = gcd(n.abs, d.abs)
      val numer = n / g
      val denom = d / g

      def this(n: Int) = this(n, 1)

      def + (that: Rational): Rational =
        new Rational(
          numer * that.denom + that.numer * denom,
          denom * that.denom
        )

      def + (i: Int): Rational =
        new Rational(numer + i * denom, denom)

      def - (that: Rational): Rational =
        new Rational(
          numer * that.denom - that.numer * denom,
          denom * that.denom
        )

      def - (i: Int): Rational =
        new Rational(numer - i * denom, denom)

      def * (that: Rational): Rational =
        new Rational(numer * that.numer, denom * that.denom)

      def * (i: Int): Rational =
        new Rational(numer * i, denom)

      def / (that: Rational): Rational =
        new Rational(numer * that.denom, denom * that.numer)

      def / (i: Int): Rational =
        new Rational(numer, denom * i)

      override def toString = numer +"/"+ denom

      private def gcd(a: Int, b: Int): Int = 
        if (b == 0) a else gcd(b, a % b)
    }

    object Main {
      def main(args: Array[String]) {
        val x = new Rational(2, 3)
        println("x [" + x + "]")
        println("x * x [" + (x * x) + "]")
        println("x * 2 [" + (x * 2) + "]")

        implicit def intToRational(x: Int) = new Rational(x)
        val r = new Rational(2,3)
        println("2 * r [" + (2 * r) + "]")
      }
    }
  #+END_SRC

* 内建控制结构
  if,while,for,try,match及函数调用。
** if
   使用val，能让代码即容易阅读又容易重构。
   val的好处：
   + 代码变量不变 :: 节省审查变量作用域的所有代码，以及检查它是否改变的工作。
   + 支持等效推论（equational reasoning) :: 无论何时都可以用表达式代替变量名。

    #+BEGIN_SRC scala
       var filename = "default.txt"
       if (!args.isEmpty)
          filename = args(0)

      改写为：
       val filename =
          if (!args.isEmpty) args(0)
          else "default.txt"
    #+END_SRC

** while
   通常情况下，要质疑对wile循环的使用，如果质疑对var的使用那样。
   while循环不产生值，通常被纯函数式语言所舍弃，为了让程序发挥作用，while循环通常不是更新var就是执行I/O。
   如果用函数式风格编写，一般要用递归实现。

   递归的实现：默认的最大公约数函数gcdloop使用了var和while循环。
   下边的采用了递归而不需要while和var.

   #+BEGIN_SRC scala
      def gcd(x: Long, y: Long): Long =  //返回最大公约数
         if (y == 0) x else gcd(y, x % y) 
   #+END_SRC

** for
   可以用来枚举集合类。
   可以在for中过滤和判断。
  
   #+BEGIN_SRC scala
     val filesHere = (new java.io.File("/home/kay")).listFiles
     for(file <- filesHere if file.getName.endsWith(".scala")) 
       println(file)

     for(i <- 1 to 4)
       println("Iteration " + i)

    for (
      file <- filesHere
      if file.isFile;
      if file.getName.endsWith(".scala")
    ) println(file)
   #+END_SRC

   嵌套枚举： 当加入多个 <- 字句的时候，就得到了嵌套的“循环”。

   #+BEGIN_SRC scala
     def fileLines(file: java.io.File) =
       scala.io.Source.fromFile(file).getLines.toList

     def grep(pattern: String) =
       for(
         file <- filesHere
         if file.getName.endsWith(".scala");
         line <- fileLines(file)
         trimmed = line.trim //把结果绑定到变量上，绑定的变量被当作val引入和使用，但不用带val关键字
         if trimmed.matchs(pattern)
       ) println(file + ": " + trimmed)

     grep(".*gcd.*")
   #+END_SRC

   用yield 制造新集合: 只要在for表达式之前加上关键字yield.
   语法： for {子句} yield {循环体}

   #+BEGIN_SRC scala
     def scalaFiles =
         for {
           file <- filesHere
           if file.getName.endsWith(".scala")
         } yield file
   #+END_SRC

** try
   scala中try-catch-finally也产生值。由finally子句计算得到的值，即使有也会被抛弃，finally之用于关闭文件等的清理工作。

   #+BEGIN_SRC scala
      import java.net.URL
       import java.net.MalformedURLException

       def urlFor(path: String) =
         try {
           new URL(path)
         } catch {
           case e: MalformedURLException =>
             new URL("http://www.scala-lang.org")
         }
   #+END_SRC

** match表达式
   类似于switch语句。
   基本上match表达式可以用认识的模式（match）做选择。
   在java中case语句只能是整数类型和枚举常量。在scala中匹配表达式可以是任何类型的常量，都能当初scala里做比较用的case.
   scala中break是隐含的。并且mactch表达式也可以产生值。

   #+BEGIN_SRC scala
     val firstArg = if (!args.isEmpty) args(0) else ""

       val friend =
         firstArg match {
           case "salt" => "pepper"
           case "chips" => "salsa"
           case "eggs" => "bacon"
           case _ => "huh?"
         }           

       println(friend)
   #+END_SRC

** 不再使用break和continue
   用if代替continue, 用布尔变量代替每个break是最简单的形式; 也可以把循环重写为递归函数(可以省略var变量)。

   #+BEGIN_SRC scala
     // java的版本
      int i = 0;                // This is Java
       boolean foundIt = false;
       while (i < args.length) {
         if (args[i].startsWith("-")) {
           i = i + 1;
           continue;
         }
         if (args[i].endsWith(".scala")) {
           foundIt = true;
           break;
         }
         i = i + 1;
       }

     //用if和布尔判断代替continue和break
     var i = 0
       var foundIt = false

       while (i < args.length && !foundIt) {
         if (!args(i).startsWith("-")) {
           if (args(i).endsWith(".scala"))
             foundIt = true
         }
         i = i + 1
       }

     //写成递归函数，可以省略var变量
     def searchFrom(i: Int): Int =
         if (i >= args.length) -1
         else if (args(i).startsWith("-")) searchFrom(i + 1) 
         else if (args(i).endsWith(".scala")) i
         else searchFrom(i + 1)

       val i = searchFrom(0)
   #+END_SRC

** 用函数式风格重构指令式风格的乘法表

   #+BEGIN_SRC scala
      // Returns a row as a sequence
       def makeRowSeq(row: Int) =
         for (col <- 1 to 10) yield {
           val prod = (row * col).toString
           val padding = " " * (4 - prod.length)
           padding + prod
         }

       // Returns a row as a string
       def makeRow(row: Int) = makeRowSeq(row).mkString

       // Returns table as a string with one row per line
       def multiTable() = {

         val tableSeq = // a sequence of row strings
           for (row <- 1 to 10)
           yield makeRow(row)

         tableSeq.mkString("\n")
       }
   #+END_SRC

* 函数和闭包
  函数式语言的基础建设模块，函数。
  把大程序分割成小的片段。
  scala提供了很多java中没有的定义函数的方式：
  + 作为对象成员的函数
  + 内嵌在函数中的函数
  + 函数字面量和函数值
    
** 本地函数
   像定义本地变量一样可以把函数定义在别的函数内部。
   本地函数能够访问包含其函数的参数。
   嵌套和作用域原则可以应用于所有的scala架构，包括函数。

   #+BEGIN_SRC scala
      import scala.io.Source

       object LongLines {

         def processFile(filename: String, width: Int) {

           def processLine(line: String) {
             if (line.length > width)
               print(filename +": "+ line)
           }    

           val source = Source.fromFile(filename)
           for (line <- source.getLines)
             processLine(line)
         }
       }
   #+END_SRC

** 头等函数
   不仅可以定义和调用函数，还可以把他们写成匿名的字面量（literal),并把他们作为值传递。
   函数字面量和值的区别在于字面量存在于源代码，而函数值作为对象存在于运行期;类似于类（源代码）和对象（运行期）的区别
   (x: Int) => x + 1  //这个函数可以把任意的x映射为x+1.

   #+BEGIN_SRC scala
     var increase = (x: Int) => x + 1
     increase(10)
   #+END_SRC

   函数字面量可以包含多条语句，用花括号包住，组成代码块;函数的返回值是最后一行表达式产生的值。

** 字面量的短格式
   + 去除参数类型
   + 去除无用字符

     #+BEGIN_SRC scala
       val someNumbers = List(-11, -10, -5, 0, 5, 10)
       someNumbers.filter((x) => x > 0)

       // 短格式
       someNumbers.filter(x => x > 0)
     #+END_SRC

** 占位符语法 _
   可以把下划线当作一个或者更多参数的占位符。
   多个下划线指待多个参数。

   #+BEGIN_SRC scala
      someNumbers.filter(x => x > 0)

     // 占位符
     someNumbers.filter(_ > 0)
   #+END_SRC

** 部分应用函数
   部分应用函数是一种表达式，不需要提供函数的所有参数，只需要提供部分或者不提供参数，取而代之用 “_”。
   foreach需要一个函数作为参数输入

   #+BEGIN_SRC scala
     def sum(a: Int, b: Int, c: Int) = a + b + c
     val a = sum _
     a(1, 2, 3)
   #+END_SRC

** 闭包 closure
   函数字面量在运行时创建的函数值(对象)被成为闭包（需要包含自由变量）。
    不带自由变量的函数字面量成为封闭项（closed term).

    #+BEGIN_SRC scala
      (x: Int) => x + 1  //closed term

      (x: Int) => x + more  // 闭包
    #+END_SRC
    任何以(x: Int) => x + more为模板在运行期创建的函数值将必须捕获对自由变量more的绑定。

    java的内部类不允许访问i外围范围内可以改变的变量。
    闭包在运行期改变的自由变量值，仍然在闭包之外可见。

    #+BEGIN_SRC scala
      //创建和返回“递增”闭包的函数
      def makeIncreaser(more: Int) = (x: Int) => x + more

      val inc2 = makeIncreaser(2)
      inc2(4)  //output 6
    #+END_SRC

** 重复参数
   允许向函数传入可变长度参数列表: 在参数类型之后放一个星号。

   #+BEGIN_SRC scala
     def echo(args: String*) = 
       for (arg <- args) println(arg)

     echo("hello", "world")
   #+END_SRC

** 尾递归
   最后一个动作调用自己的函数，成为尾递归。
   尾递归函数将不会为每个调用开辟新的堆栈结构，所有的调用将在一个结构内执行。
   scala编译器会优化尾递归。

   函数调用应尽量被实现为优化的尾调用。

   #+BEGIN_SRC scala
     def approximate(guess: Double): Double = 
         if (isGoodEnough(guess)) guess
         else approximate(improve(guess))
   #+END_SRC

* 控制抽象
  自定义控制抽象来增强scala的基本控制结构，柯里化和传名参数。

  用高阶函数去重复所有程序源代码中常见的控制模式，使用currying和传名参数使高阶函数简洁。
  函数分为通用部分（函数体）和非通用部分(参数)
** 高阶函数
   高阶函数的好处：减少代码重复；简化客户端代码编写。
   1. 通过创造控制抽象，从而减少代码重复

      #+BEGIN_SRC scala
        object Files1 {
          object FileMatcher {
            private def filesHere = (new java.io.File(".")).listFiles
          
            def filesEnding(query: String) =
              for (file <- filesHere; if file.getName.endsWith(query))
                yield file

            def filesContaining(query: String) =
              for (file <- filesHere; if file.getName.contains(query))
                yield file

            def filesRegex(query: String) =
              for (file <- filesHere; if file.getName.matches(query))
                yield file
          }

          def main(args: Array[String]) {
            println("FileMatcher.filesEnding(\"scala\").toList [" +
                    FileMatcher.filesEnding("scala").toList + "]")
            println("FileMatcher.filesContaining(\"Files1\").toList [" + 
                    FileMatcher.filesContaining("Files1").toList + "]")
            println("FileMatcher.filesRegex(\".*Re.ex.*\").toList [" + 
                    FileMatcher.filesRegex(".*Re.ex.*").toList + "]")
          }
        }
      #+END_SRC

      在scala中不允许在运行期粘合代码，所以下边的定义不对。不能把方法名当作值传递。
      #+BEGIN_SRC scala
        // 不正确 不允许 粘合method.  file.getName.method(query) 
        def fileMatching(query: String, method) = 
          for(file <- filesHere; if file.getName.method(query)) 
            yield file
      #+END_SRC

      + 第一次重构 :: 
        虽然不能把方法名当作值传递，但是可以通过传递调用方法的函数值达到同样的效果：添加一个matcher参数

                      #+BEGIN_SRC scala
                        object Files2 {
                          def filesHere = (new java.io.File(".")).listFiles

                          def filesMatching(query: String,
                              matcher: (String, String) => Boolean) = {

                            for (file <- filesHere; if matcher(file.getName, query))
                              yield file
                          }

                          def filesEnding(query: String) =
                            filesMatching(query, _.endsWith(_))

                          def filesContaining(query: String) =
                            filesMatching(query, _.contains(_))

                          def filesRegex(query: String) =
                            filesMatching(query, _.matches(_))

                          def main(args: Array[String]) {
                            println("filesEnding(\"scala\").toList [" +
                                    filesEnding("scala").toList + "]")
                            println("filesContaining(\"Files1\").toList [" + 
                                    filesContaining("Files1").toList + "]")
                            println("filesRegex(\".*Re.ex.*\").toList [" + 
                                    filesRegex(".*Re.ex.*").toList + "]")
                          }
                        }
                      #+END_SRC

      + 第二次重构 :: 用闭包减少参数传来传去的问题。

                      #+BEGIN_SRC scala
                        object Files {
                          object FileMatcher {
                            private def filesHere = (new java.io.File(".")).listFiles
                          
                            private def filesMatching(matcher: String => Boolean) =
                              for (file <- filesHere; if matcher(file.getName))
                                yield file
                          
                            def filesEnding(query: String) =
                              filesMatching(_.endsWith(query))
                          
                            def filesContaining(query: String) =
                              filesMatching(_.contains(query))
                          
                            def filesRegex(query: String) =
                              filesMatching(_.matches(query))
                          }

                          def main(args: Array[String]) {
                            println("FileMatcher.filesEnding(\"scala\").toList [" +
                                    FileMatcher.filesEnding("scala").toList + "]")
                            println("FileMatcher.filesContaining(\"Files1\").toList [" + 
                                    FileMatcher.filesContaining("Files1").toList + "]")
                            println("FileMatcher.filesRegex(\".*Re.ex.*\").toList [" + 
                                    FileMatcher.filesRegex(".*Re.ex.*").toList + "]")
                          }
                        }
                      #+END_SRC

   2. 简化客户代码 ::
      类似集合类型特定用途循环方法。
      exists方法代表了控制抽象。

      #+BEGIN_SRC scala
        def containsOdd(nums: list[Int]) = nums.exists(_ % 2 == 1)
      #+END_SRC

** currying(柯里化)
   currying的函数式编程技巧。

   #+BEGIN_SRC scala
     def plainOldSum(x: Int, y: Int) = x + y

     //currying后
     def currentSum(x: Int)(y: Int) = x + y
   #+END_SRC

** 编写新的控制结构
   可以使用花括号代替小括号包围参数，但是，花括号的技巧仅在传入一个参数时有效。

   #+BEGIN_SRC scala
     import java.io._

     object WithPrintWriter2 {
       def withPrintWriter(file: File)(op: PrintWriter => Unit) {
         val writer = new PrintWriter(file)
         try {
           op(writer)
         } finally {
           writer.close()
         }
       }

       def main(args: Array[String]) {
         val file = new File("date.txt")
         
         withPrintWriter(file) {
           writer => writer.println(new java.util.Date)
         }
       }
     }
   #+END_SRC

   *by-name parameter(传名参数)*
   要实现一个by-name parameter就要让参数的类型开始于 "=>" 而不是 "() =>" 或者 "PrintWriter =>"等。

* 组合与继承
  scala更多对面向对象的支持，实践中经常出现。
  In addition to these topics, we’ll discuss abstract classes, pa-
rameterless methods, extending classes, overriding methods and fields, para-
metric fields, invoking superclass constructors, polymorphism and dynamic
binding, final members and classes, and factory objects and methods.

** 抽象类
   一个方法只要没有实现（即没有等号或者方法体），它就是抽象的。抽象方法的声明不需要抽象修饰符。

   #+BEGIN_SRC scala
     abstract class Element {
       def contents: Array[String]
     }
   #+END_SRC

** 定义无参数方法
   1. 无参数方法，在scala中非常普通: def height: Int
   2. 空括号方法，带有空括号的方法定义: def height(): Int
   统一访问原则(uniform access principle): 客户代码不应由属性是通过字段实现还是方法实现而受到影响。
   惯例：无论何时，只要方法没有参数，并且方法仅能通过读取所包含对象的属性去访问可变状态，就使用无参数方法。

   原则上，scala的函数调用可以省略所有的空括号。然后，在调用的方法超出其调用者对象的属性时，推荐仍然写一对空括号。例如：如果方法执行了I/O,或写入可重复赋值的变量（var），或读取不是调用折字段的var，总之，无论是直接还是非直接使用可变对象，都应该添加空括号。

   scala鼓励使用将不带参数且没有副作用的方法定义为无参数方法的风格。
   但是永远不要定义没有括号的带副作用的方法。

   如果调用的函数执行了操作就使用括号，如果仅提供对某个属性的访问，就省略分号。

   #+BEGIN_SRC scala
     "hello".length  // 没有副作用，所以无需()
     println()  // 最好别省略()
   #+END_SRC

** 扩展类
   继承（inheritance）表示超类的成员也是子类的成员。
   但以下两种情况例外：
   1. 超类的私有成员不能被子类继承。
   2. 子类重写超类成员的时候。
   子类型化(subtyping)：子类的值可以在任何需要其超类的值的地方使用。

   #+BEGIN_SRC scala
     class ArrayElement(conts: Array[String]) extends Element {
         def contents: Array[String] = conts
       }

     //  子类型化(subtyping)：子类的值可以在任何需要其超类的值的地方使用。
       scala> val ae = new ArrayElement(Array("hello", "world"))
       ae: ArrayElement = ArrayElement@d94e60
   #+END_SRC

   scala和java的命名空间的不同：
   1. java有四个命名空间（字段，方法，类型和包）
   2. scala有两个命名空间 \\
      + 值（字段，方法，包，单例对象）
      + 类型（类和特质名）
   scala把字段和方法放进统一个命名空间，所以可以实现使用val重写无参数方法（在java中无法做到）。

   #+BEGIN_SRC scala
      abstract class Element {
         def contents: Array[String]
       }

     // 改变contents的实现从一个方法变为一个字段
      class ArrayElement(conts: Array[String]) extends Element {
         val contents: Array[String] = conts
       }
   #+END_SRC

** 定义参数化字段
   类的参数同样可以使用var做前缀，这时字段可以被重新赋值。
   参数化字段也可以添加如private, protected, override这类的修饰符。

   #+BEGIN_SRC scala
      class Cat {
         val dangerous = false
       }

     // 定义参数化字段
       class Tiger(
         override val dangerous: Boolean,  // 字段名与超类相同
         private var age: Int
       ) extends Cat

     // 上边的定义是下边这种类定义方式的简写
       class Tiger(param1: Boolean, param2: Int) extends Cat {
         override val dangerous = param1
         private var age = param2
       }
   #+END_SRC

** 调用超类构造器
   当超类构造器需要带参数时，子类需要传给超类的主构造器一个参数; 要调用超类构造器，只要简单地把要传递的参数或参数列表放在超类名之后的括号里即可。

   #+BEGIN_SRC scala
      class LineElement(s: String) extends ArrayElement(Array(s)) {
         override def width = s.length
         override def height = 1
       }
   #+END_SRC

** override修饰符
   scala要求一下三点：
   1. 若子类成员重写了父类的具体成员时，则必须带有override修饰符；
   2. 若成员实现的是同名的抽象成员时，这个修饰符是可选的；
   3. 若成员并未重写或实现什么其他基类里的成员，则禁用这个修饰符。

** 定义final成员
   需要定义为final的情况：
   + 要确保一个成员不被子类重写
   + 要确保整个类不会有子类

** 其他
   ++操作符可以连接两个数组

   #+BEGIN_SRC scala
      def above(that: Element): Element =
         new ArrayElement(this.contents ++ that.contents)
   #+END_SRC

   #+BEGIN_SRC scala
       def beside(that: Element): Element = {
         val contents = new Array[String](this.contents.length)
         for (i <- 0 until this.contents.length)  //until与to类似，只是不包含尾部：0 to (this.contents.length - 1)
           contents(i) = this.contents(i) + that.contents(i)
         new ArrayElement(contents)
       }

     // 可以简写为以下形式
     new ArrayElement(
         for (
           (line1, line2) <- this.contents zip that.contents
         ) yield line1 + line2
       )

     // zip操作的含义
       Array(1, 2, 3) zip Array("a", "b") // result为：Array((1, "a"), (2, "b"))
   #+END_SRC

** 定义工厂对象
   可以创建伴生对象，把它作为布局元素的工厂方法。

   #+BEGIN_SRC scala
      object Element {

         private class ArrayElement(
           val contents: Array[String]
         ) extends Element

         private class LineElement(s: String) extends Element {
           val contents = Array(s)
           override def width = s.length
           override def height = 1
         }

         private class UniformElement(
           ch: Char,
           override val width: Int,
           override val height: Int
         ) extends Element {
           private val line = ch.toString * width
           def contents = Array.make(height, line)
         }

         def elem(contents:  Array[String]): Element =
           new ArrayElement(contents)

         def elem(chr: Char, width: Int, height: Int): Element =
           new UniformElement(chr, width, height)

         def elem(line: String): Element =
           new LineElement(line)
       }

   #+END_SRC

* scala的层级
  继承层级，以及scala的全体方法及底层类型
  在scala中，每个类都继承自Any的超类，在层级的低端还有两个通用的子类：Null和Nothing.
  Null is a subtype of all reference types; its only instance is the null reference. Since Null is not a subtype of value types, null is not a member of any such type. For instance, it is not possible to assign null to a variable of type scala.Int.
  Nothing is a subtype of every other type (including scala.Null); there exist no instances of this type.
  Any有两个子类：AnyVal和AnyRef。
  AnyVal是每个内建值类的父类。有9个内建值类：Byte, Short, Char, Int, Long, Float, Double, Boolean, Unit.
  Unit 对应于java中的void,Unit只有一个实例，写为().
  Int可以隐式转换到RichInt上，方法min,max,util,to,abs等都定义在scala.runtime.RichInt上，所以Int也可以用。

  Nothing的一个应用，在scala标准库中Predef对象有一个error方法，定义如下：

  #+BEGIN_SRC scala
     def error(message: String): Nothing =
        throw new RuntimeException(message)

     def divide(x: Int, y: Int): Int = 
        if (y != 0) x / y 
        else error("can't divide by zero")  // 因为Nothing是任意类的子类，所以可以把Nothing赋值给Int，所以返回值仍为Int
  #+END_SRC

* 特质(trait)
  演示在混入组成(mixin composition)中的机制。 演示特质如何工作，描述了通常的用法，解释为什么特质改善了传统的多继承。
  特质封装了方法和字段的定义，类可以混入任意多个特质。
  特质最常用的两个方式：
  1. 拓宽瘦接口为胖接口
  2. 定义可堆叠的改变。
  
  特质和其他语言中多重继承的区别？

** trait的工作方式

    trait的定义除了使用关键字trait之外，与类的定义无异。但是trait不能定义可变参数。
    trait被定义之后，可以用extends或with关键字，把它混入到类中。
    如果想把特质混入显示扩展超类的类中，可以用extends指明待扩展的超类，用with混入特质。

    可以用特质的定义做任何类定义能做的事，除了以下亮点不同之外语法也相同：
    1. 特质不能有任何“类”参数（传入给类的主构造器的参数）
    2. 在特质中，super的调用是动态绑定的。而不论在哪里，类的super调用都是静态绑定的. \\
       特质中的super调用是线性的。
       class Cat extends Animal with Furry with Fourlegged  的调用顺序为： \\
       Cat, FourLegged, Furry, Animal, AnyRef, Any
       
       如果这些类和特质中任何一个通过super调用了方法，那么被调用的实现将是它线性化的右侧的一个实现。
       
    #+BEGIN_SRC scala
        trait Philosophical {
          def philosophize() {
            println("I consume memory, therefore I am!")
          }
        }
    #+END_SRC

    #+BEGIN_SRC scala
      class Animal

        class Frog extends Animal with Philosophical with Haslegs {
          override def toString = "green"
        }
    #+END_SRC

** Ordered特质
   利用ordered特质定义<,>,<=,>=操作。Ordered特质没有定义equals方法，需要自己定义。
   有两件事情要做：
   + 混入Ordered特质（需要在混入的时候设定类型参数）。
   + 定义compare方法来比较两个对象。

     #+BEGIN_SRC scala
        class Rational(n: Int, d: Int) extends Ordered[Rational] {
           // ...
           def compare(that: Rational) =
             (this.numer * that.denom) - (that.numer * this.denom)
         }

     #+END_SRC

** trait用来做可堆叠的改变
   trait可以改变类的方法。trait是可堆叠的。
   trait在声明为抽象的方法中可以有super调用，而这种调用 在普通的类中是非法的。因为trait的super调用是动态绑定的。
   super调用在实现可堆叠改动的特质来说常用到，为了告诉编译器目的是什么，还不须对这种方法打上abstract override的标志，这种标志在类中也是非法的。
   trait的混入次序是非常重要的，越靠近右侧的特质越先其作用。右侧特质的方法先被调用，如果这个方法调用了super,他调用其左侧特质的方法。
   应时刻关注是否有机会以可堆叠的改变方式安排代码。

   #+BEGIN_SRC scala
       abstract class IntQueue {
         def get(): Int
         def put(x: Int)
       }

      trait Doubling extends IntQueue {
         abstract override def put(x: Int) { super.put(2 * x) }  // abstrat override . then super invoke
       }

       trait Incrementing extends IntQueue {
         abstract override def put(x: Int) { super.put(x + 1) }
       }

       trait Filtering extends IntQueue {
         abstract override def put(x: Int) {
           if (x >= 0) super.put(x)
         }
       }

       scala> val queue = (new BasicIntQueue
            |     with Incrementing with Filtering)  // 匿名类用两个trait堆叠修改方法。
       queue: BasicIntQueue with Incrementing with Filtering...

       scala> queue.put(-1); queue.put(0); queue.put(1)

       scala> queue.get()
       res15: Int = 1

       scala> queue.get()
       res16: Int = 2

   #+END_SRC

** 什么时候用trait
   1. 如果行为不重复，做成具体类。
   2. 要在多个不相关的类中重用，做成trait。只有trait可以混入到不同的类层级中。
   3. 如果希望从java代码中继承，就使用抽象类。
      
* 包和引用
  讨论大项目中的事物：顶层包，引用语句，访问控制修饰符(如protected,private).
  减小耦合的方式之一：使用模块化风格编写代码；将程序分为若干小模块，把每块分为内部和外部。当必须改变模块的外部（即模块的接口）时，才需要和工作于其他模块的开发人员交互。
  使用对象的模块化编程比分割包更灵活。

** 包
   可以用两种方式把代码放在命名包中：
   + 通过package子句放在文件顶端的方式把整个文件内容放进包里。
   + 可以在package子句之后把要放到包中的定义用花括号括起来 :: 
     可以把类的测试与原始代码放在同一个文件，但在不同的包里。
        scala在所有用户可创建的包之外提供了名为_root_的包，任何能写出来的顶层包都被当作_root_包的成员。
     
        #+BEGIN_SRC scala
          // first 
          package bobsrockets.navigation
            class Navigator

          // second
           package bobsrockets.navigation {

              // In package bobsrockets.navigation
              class Navigator

              package tests {

                // In package bobsrockets.navigation.tests
                class NavigatorSuite
              }
            }
        #+END_SRC

** 引用
   包和其他成员的引用用import子句。

   scala的import语句和java的主要差异：
   + 在scala中引用可以出现在任何地方。
   + 可以指的是（单例或正统的）对象和包。
   + 可以重命名或隐藏一些被引用的成员。

   引用选择器可以包括以下模式：
   + 简单名x。 :: 把x包含进引用名集。
   + 重命名子句x => y。
   + 隐藏子句x => _。 :: 把x排除在引用名集之外
   + 全包括 _ 。 :: 如果存在全包括，那么必须是引用选择的最后一个。
     
   scala隐式为每个源文件添加三个引用：
   + import java.lang._
   + import scala._
   + import Predef._
     
   出现在靠后位置的引用将覆盖靠前的引用。
   
     #+BEGIN_SRC scala
        // easy access to Fruit
         import bobsdelights.Fruit

         // easy access to all members of bobsdelights
         import bobsdelights._

         // easy access to all members of Fruits
         import bobsdelights.Fruits._

         // 重命名Apple为McIntosh
         import Fruits.(Apple => McIntosh)

         //importFruits下除了Apple的所有成员
         import Notebooks._
         import Fruits.{Apple => _, _}
     #+END_SRC

** 访问修饰符
   包，类和对象的成员可以用访问修饰符private和protected标记。没有标记的为公开的。
   标记为private的成员仅在包含了成员定义的类或者对象内部可见，内部类也应用同样的规则，外部类不能调用内部类的private引用。
   protected保护成员只能在类和类的子类中被访问，在同一包中的其他类也不能访问。

   #+BEGIN_SRC scala
      class Outer {
         class Inner {
           private def f() { println("f") }
           class InnerMost {
             f() // OK
           }
         }
         (new Inner).f() // error: f is not accessible
       }

       package p {
         class Super {
           protected def f() { println("f") }
         }
         class Sub extends Super {
           f()
         }
         class Other {
           (new Super).f()  // error: f is not accessible
         }
       }

   #+END_SRC

*** 保护的作用域
    scala中访问修饰符可以通过使用限定词强调。
    如：private[x], protected[x] 表示直到x的私有或者保护；x指待某个所属的包，类或单例对象。

    scala还有一种比private更严格的访问修饰符private[this].被它标记的仅能在包含了定义的同一个对象中被访问。

    #+BEGIN_SRC scala
      package bobsrockets {
         package navigation {
           private[bobsrockets] class Navigator { 
             protected[navigation] def useStarChart() {}
             class LegOfJourney {
               private[Navigator] val distance = 100
             }
             private[this] var speed = 200
           }
         }
         package launch {
           import navigation._
           object Vehicle { 
             private[launch] val guide = new Navigator
           }
         }
       }
    #+END_SRC

*** 可见性和伴生性
    scala中代替静态成员的是，可以拥有包含成员的单例的伴生对象。
    类的所有访问权限都对伴生对象开放，反过来也如此。对象可以访问所以它的伴生类的私有成员。

* 断言和单元测试
  scala的断言机制，各种可以为scala编写测试的工具。
  断言可以直接混合在生产代码中，也可以放在外部的单元测试中。
  不仅可以用java社区流行的测试工具：JUnit和TestNG；
  还可以用scala的测试工具：ScalaTest, ScalaCheck,specs。

** 断言
   assert, ensuring.
   assert和ensuring可以使用JVM的-ea 和 -da 命令行标志开放和禁止。

   assert可以带一个参数或者两个参数。
   ensuring 放发带一个函数做参数。

   #+BEGIN_SRC scala
       // assert
       def above(that: Element): Element = { 
         val this1 = this widen that.width 
         val that1 = that widen this.width 
         assert(this1.width == that1.width)
         elem(this1.contents ++ that1.contents) 
       }

       // ensuring
       private def widen(w: Int): Element =
         if (w <= width) 
           this 
         else { 
           val left = elem(' ', (w - width) / 2, height) 
           var right = elem(' ', w - width - left.width, height) 
           left beside this beside right 
         } ensuring (w <= _.width)
   #+END_SRC

** 单元测试
*** ScalaTest
    简单扩展org.scalatest.Suite类
    Suite代表一个测试集，测试方法名以test开头。可以直接在scala解释器中通过调用execute方法运行Suite.

* 样本类和模式匹配
  是在编写正规的非封装的数据结构时用到的工具，尤其对树型递归数据很有用

* 使用列表
  最常用到的数据结构

* 集合类型
  如何使用scala集合类型：列表，数组，元组集（tuple）及映射表

* 有状态的对象
  什么是有状态（可变）的对象，scala提供语法层面表达他们的术语。
  包括一个在离散事件模拟上的案例研究，用来演示一些有状态对象的动作

  在scala中字段不可以随意省略"=_"初始化器。如果：
   var celsius: Float = _ 写为 var celsius: Float ，将定义为抽象变量，而不是未初始化的变量。
  #+BEGIN_SRC scala
     class Thermometer {

        var celsius: Float = _

        def fahrenheit = celsius * 9 / 5 + 32
        def fahrenheit_= (f: Float) {
          celsius = (f - 32) * 5 / 9
        }
        override def toString = fahrenheit +"F/"+ celsius +"C"
      }
  #+END_SRC

* 类型参数化
  纯函数队列类的设计，以及一些信息隐藏技术。
  本章建立了关于各种类型参数的描述，以及它如何与信息隐藏实现交互。

** 变化型注解
   参数的变化型：协变（类型参数前的+）(covariant)，逆边（类型参数前的-）(contravariant)，非协变（类型参数前没有符号）(nonvariant)。
   + 非协变 ::
     trait Queue[T] {...}
   + 协变 :: 
     trait Queue[+T] {...}
     正常类型参数前+号表明这个参数的子类型化是协变（弹性）的。比如String是AnyRef的子类型，那么Queue[String]将当作Queue[AnyRed]的子类型。
   + 逆变 :: 
     trait Queue[-T] {...}
     -号表明参数的子类型化是逆变的,如果T是类型S的子类型，那么隐含Queue[S]是Queue[T]的子类型。
     
   超类型：语法"U >: T"，定义了T为U的下界。
   超类型和子类型的关系是自反的，亦类型对于自身来讲，既是超类型，也是子类型。

   #+BEGIN_SRC scala
     def append[U >: T](x: U) = new Queue[U] (leading, x :: trailing)  // ...
   #+END_SRC

   类型驱动设计。
   里氏替代原则(Liskov Substitution Principle, LSP): 如果能在需要类型U 的值的地方替换成类型T 的值，那么类型T 是类型U 的子类型的假设就是安全的。

* 抽象成员
  能够声明为抽象的有方法，字段，类型。

* 隐式转换和参数
  不懂
  这两个特性有助于程序员忽略掉源码中那些能由编译器推导出来的繁琐的细节的特性。

* 实现列表
  描述list类的实现。实现本身也展示了若干scala特性的应用。

* 重访for表达式
  解释for表达式如何翻译成对map,flatMap,filter,foreach的访问。

* Extractors(抽取器)
  展示了如何使用模式匹配任何类，而不仅仅是用例类。

* 注解
  通过注解使用语言的扩展部分。示范若干标准注解以及建立自己的注解

* 使用XML
  处理XML。包括创建，解析以及解析之后处理等一系列惯用方式。

* 使用对象的模块化编程
  说明消除了分离式模块系统的使用需求。

* 对象相等性
  指出若干在编写equals方法时要考虑的情况。
  说明了若干应避免的误区。

* 结合scala和java
  在同一项目中捆绑使用java和scala时会碰到的状况，以及建议的解决方法。

* actor和并发
  如何使用actor并发库。
  尽管使用java平台的同步原语和来自与scala程序的库，但actor能帮助避免死锁和资源竞争这些传统的并发问题。

* 连接符解析(跳过了）
  演示如何使用scala的解析器连接符来创建解析器。

* GUI编程
  简化基于swing的GUI编程。

* SCells试算表
  通过一个完整的试算表的实现，集中演示了scala的一切。

* FQA
  case类的用法，模式
