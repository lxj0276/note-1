* 内核数据结构
** 链表
linux 内核的标准链表是环形双向链表. 
如果要随机访问数据, 一般不适用链表.
适用链表的理想情况是: 需要便利所有的数据或需要动态加入和删除数据时.
*** 单向链表
    #+BEGIN_SRC C++
      struct list_element {
        void *data;
        struct list_element *next;
      }
    #+END_SRC

*** 双向链表
    #+BEGIN_SRC C++
      struct list_element {
        void *data;
        struct list_element *next;
        struct list_element *prev;
      }
    #+END_SRC
** 队列
** 映射
** 二叉树
*** 环形链表
* 第 1 章 简介和概述 
1.1 内核的任务 
1.2 实现策略 
1.3 内核的组成部分 
1.3.1 进程、进程切换、调度 
1.3.2 UNIX 进程 
1.3.3 地址空间与特权级别 
1.3.4 页表 
1.3.5 物理内存的分配 
1.3.6 计时 
1.3.7 系统调用 
1.3.8 设备驱动程序、块设备和字符设备 
1.3.9 网络 
1.3.10 文件系统 
1.3.11 模块和热插拔 
1.3.12 缓存 
1.3.13 链表处理 
1.3.14 对象管理和引用计数 
1.3.15 数据类型 
1.3.16 本书的局限性 
1.4 为什么内核是特别的 
1.5 行文注记 
1.6 小结 
* 第 2 章 进程管理和调度
** 2.1 进程优先级 
实时进程， 非实时进程。
硬实时， 软实时
** 2.2 进程生命周期 
运行， 等待， 睡眠， 终止。
僵尸进程产生的原因：1. 程序必须由一个进程或者一个用户杀死， 进程的父进程在子进程终止时必须调用或者已经调用 wait4 系统调用。只有当第一个条件发生， 而第二个条件不成立的时候才会出现僵尸状态。
** 2.3 进程表示 
2.3.1 进程类型 
2.3.2 命名空间 
2.3.3 进程 ID 号 
2.3.4 进程关系 
** 2.4 进程管理相关的系统调用
2.4.1 进程复制 
  1. fork 重量级
  2. vfork 不具有优势， 尽量不 要用
  3. clone 产生线程。

  写时复制。

2.4.2 内核线程 
2.4.3 启动新程序 
2.4.4 退出进程 
2.5 调度器的实现 
2.5.1 概观 
2.5.2 数据结构 
2.5.3 处理优先级 
2.5.4 核心调度器 
2.6 完全公平调度类 
2.6.1 数据结构 
2.6.2 CFS 操作 
2.6.3 队列操作 
2.6.4 选择下一个进程 
2.6.5 处理周期性调度器 
2.6.6 唤醒抢占 
2.6.7 处理新进程 
2.7 实时调度类 
2.7.1 性质 
2.7.2 数据结构 
2.7.3 调度器操作 
2.8 调度器增强 
2.8.1 SMP 调度 
2.8.2 调度域和控制组 
2.8.3 内核抢占和低延迟相关工作 
2.9 小结 
* 第 3 章 内存管理
3.1 概述 
3.2 (N)UMA 模型中的内存组织 
3.2.1 概述 
3.2.2 数据结构 
3.3 页表 
3.3.1 数据结构 
3.3.2 页表项的创建和操作 
3.4 初始化内存管理 
3.4.1 建立数据结构 
3.4.2 特定于体系结构的设置 
3.4.3 启动过程期间的内存管理 
3.5 物理内存的管理 
3.5.1 伙伴系统的结构 
3.5.2 避免碎片 
3.5.3 初始化内存域和结点数据结构 
3.5.4 分配器 API 
3.5.5 分配页 
3.5.6 释放页 
3.5.7 内核中不连续页的分配 
3.5.8 内核映射 
3.6 slab 分配器 
3.6.1 备选分配器 
3.6.2 内核中的内存管理 
3.6.3 slab 分配的原理 
3.6.4 实现 
3.6.5 通用缓存 
3.7 处理器高速缓存和 TLB 控制 
3.8 小结 
* 第 4 章 进程虚拟内存
4.1 简介 
4.2 进程虚拟地址空间 
4.2.1 进程地址空间的布局 
4.2.2 建立布局 
4.3 内存映射的原理 
4.4 数据结构 
4.4.1 树和链表 
4.4.2 虚拟内存区域的表示 
4.4.3 优先查找树 
4.5 对区域的操作 
4.5.1 将虚拟地址关联到区域 
4.5.2 区域合并 
4.5.3 插入区域 
4.5.4 创建区域 
4.6 地址空间 
4.7 内存映射 
4.7.1 创建映射 
4.7.2 删除映射 
4.7.3 非线性映射 
4.8 反向映射 
4.8.1 数据结构 
4.8.2 建立逆向映射 
4.8.3 使用逆向映射 
4.9 堆的管理 
4.10 缺页异常的处理 
4.11 用户空间缺页异常的校正 
4.11.1 按需分配/调页 
4.11.2 匿名页 
4.11.3 写时复制 
4.11.4 获取非线性映射 
4.12 内核缺页异常 
4.13 在内核和用户空间之间复制数据 
4.14 小结 
* 第 5 章 锁与进程间通信
* 第 6 章 设备驱动程序
* 第 7 章 模块
* 第 8 章 虚拟文件系统 
* 第 9 章 Ext 文件系统族 
* 第 10 章 无持久存储的文件系统 
* 第 11 章 扩展属性和访问控制表 
* 第 12 章 网络 
* 第 13 章 系统调用
* 第 14 章 内核活动 
* 第 15 章 时间管理 
* 第 16 章 页缓存和块缓存
* 第 17 章 数据同步
* 第 18 章 页面回收和页交换 
* 第 19 章 审计 
* 附录 A 体系结构相关知识 
* 附录 B 使用源代码 
* 附录 C 有关 C 语言的注记 
* 附录 D 系统启动 
* 附录 E ELF 二进制格式 
* 附录 F 内核开发过程 
* c language
** What does 'unsigned temp:3' in a struct or union mean?
This construct specifies the length in bits for each field.

The advantage of this is that you can control the sizeof(op), if you're careful. the size of the structure will be the sum of the sizes of the fields inside.

In your case, size of op is 32 bits (that is, sizeof(op) is 4).

The size always gets rounded up to the next multiple of 8 for every group of unsigned xxx:yy; construct.

That means:

#+BEGIN_SRC C
  struct A
  {
    unsigned a: 4;    //  4 bits
    unsigned b: 4;    // +4 bits, same group, (4+4 is rounded to 8 bits)
    unsigned char c;  // +8 bits
  };
  //                    sizeof(A) = 2 (16 bits)

  struct B
  {
    unsigned a: 4;    //  4 bits
    unsigned b: 1;    // +1 bit, same group, (4+1 is rounded to 8 bits)
    unsigned char c;  // +8 bits
    unsigned d: 7;    // + 7 bits
  };
  //                    sizeof(B) = 3 (4+1 rounded to 8 + 8 + 7 = 23, rounded to 24)
#+END_SRC
** what does __rcu stands for in linux?
Read-copy-update is an algorithm that enables concurrent access to readers of a data structure without having to lock the structure. It can be read about here.

If the kernel is built with the CONFIG_SPARSE_RCU_POINTER config option, __rcu is defined in include/linux/compiler.h as

# define __rcu          __attribute__((noderef, address_space(4)))
This is an annotation for a the Sparse code analysis tool that can warn about certain things the programmer may have overlooked. How this is relevant to RCU is explained in Documentation/RCU/checklist.txt:

__rcu sparse checks: tag the pointer to the RCU-protected data structure with __rcu, and sparse will warn you if you access that pointer without the services of one of the variants of rcu_dereference().
rcu_dereference() returns a pointer that can be safely dereferenced by the code and documents the programmer's intention to protect the pointer with the RCU mechanism, enabling tools like Sparse to check for programming errors and omissions.
[[https://www.ibm.com/developerworks/cn/linux/l-rcu/][Linux 2.6 内核中新的锁机制--RCU]]
** What are the implications of the linux __user macro?

   #+BEGIN_SRC C
     # define __user         __attribute__((noderef, address_space(1)))
   #+END_SRC
It allows tools like sparse to tell kernel developers that they're possibly using an untrusted pointer (or a pointer that may be invalid in the current virtual address mapping) improperly.
** unoin
   [[http://c.biancheng.net/cpp/html/2932.html][C 语言共用体（Union）]]
结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。
1、union 中可以定义多个成员，union 的大小由最大的成员的大小决定。 
2、union 成员共享同一块大小的内存，一次只能使用其中的一个成员。 
3、对某一个成员赋值，会覆盖其他成员的值（也不奇怪，因为他们共享一块内存。但前提是成员所占字节数相同，当成员所占字节数不同时只会覆盖相应字节上的值，比如对 char 成员赋值就不会把整个 int 成员覆盖掉，因为 char 只占一个字节，而 int 占四个字节）
4、联合体 union 的存放顺序是所有成员都从低地址开始存放的。
