* 引论
  对于大规模的输入,如何估计程序的运行时间,更重要的是,再未编码的情况下比较两个程序的运行时间.
  [[https://zh.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%87%BD%E6%95%B0][wiki指数函数]]
  [[https://zh.wikipedia.org/wiki/%E5%AF%B9%E6%95%B0][wiki对数]]
  [[http://baike.baidu.com/view/1829610.htm][百度百科对数]]

* 算法分析
* 表,栈,队列
* 树
** traversal
   前序遍历（preorder traversal）
   中序遍历（inorder traversal）
   后序遍历（postorder traversal）
** binary tree(二叉树)
   平均深度，最大深度，bianry search tree平均深度。
   二叉树有很多与搜索无关的重要应用，主要用处之一在编译器的设计领域。
** binary search tree(二叉查找树)
** AVL tree
   带有平衡条件的二叉查找树。
   每个结点的左子树和右子树的高度最多差1的二叉查找树。
*** 单旋转(single rotation)
    对a的左儿子的左子树进行一次插入，或者对a的右儿子的右子树进行一次插入。(左左，右右)
*** 双旋转(double rotation)
    对a的左儿子的右子树进行一次插入，或者对a的右儿子的左子树进行一次插入。(左右，右左)
** 伸展树(splay tree)
   当一个结点被访问后，就要经过一系列AVL树的旋转被推到根上。
   伸展分为两种情况：之字形，和一字形。
*** 之字形(zig-zag)
    其父结点和祖父结点分别在其两侧。
*** 一字形(zig-zig)
    其父结点和祖父结点分别在其同侧。
** (M-ary search tree)M叉查找树
   一颗完全M叉树的高度大约为log_M (N)
** B树
   B树是平衡M路树，能很好的适应有磁盘操作的情况。（特殊情形为2-3树）.
   阶为M的B树具有下列结构特性：
   + 数据项存储在树叶上。
   + 非叶结点存储直到M-1个键，用于指示搜索方向;键i代表子树i+1中的最小的键。
   + 树的根或者是一片树叶，或者其儿子数在2和M之间。
   + 根除外，所有非树叶结点的儿子数在M/2和M之间。
   + 所有树叶都在相同的深度上，并且都有L/2到L之间个数据项。
* 散列
  让每个key映射到适当的单元中，此映射为散列函数。
  散列表的应用。
** 散列函数的选择
** 解决冲突（collision）的方法
*** separate chaining(分离链接法)
    将散列到同一个值的所有元素保存在一个链表中。
    load factor(装填因子)是散列表中元素个数与散列表大小的比值。
    分离链接散列法的一般法则是使得表的大小尽量与预料的元素个数差不多。
    使表的大小是素数以保证一个好的分布，也是一个好的想法。
    + binary search tree
    + another hash table
*** 不使用链表的散列表(probing hash tables探测散列表)
    一般来说，要求装填因子低于0.5
    1. 线性探测 \
       会产生一次聚集问题(primary clustering)
    2. 平方探测 \
       如果使用平方探测，且表的大小是素数，那么当表至少有一半是空的时候，总能够插入一个新的元素。
       在探测山列表中标准的删除操作不能执行，如果真的删除了一个元素，则余下的find操作都将失败。
       避免了一次聚集问题，会产生二次聚集问题(secondary clustering).
    3. 双散列
*** 再散列
*** 可扩散列

* 优先队列(堆)priority queue
  应用
** binary heap
   heap的两个性质：结构性质和堆序性质。
** d heap
** leftist heap左式堆
   左式堆不是理想平衡的，趋向于非常不平衡。
** skew heap斜堆
   斜堆和左式堆的关系如同伸展树和AVL树间的关系。
** 二项队列
   一个二项队列不是一颗堆序的树，而是堆序的树的集合，成为forest森林。
   堆序树中的每一颗都有约束的形式，成为binomial tree二项树。
* 排序
* 不相交集类
** 等价关系
   满足三个性质关系R:
   1. 自反性
   2. 对称性
   3. 传递性

   *等价类* ： 包含所有与a有等价关系的元素。
** 不相交集合的union/find(求并/查找算法)
   从集合的观点来看，U的结果是建立一个新集合S=S1 U S2,去掉原来两个集合而保持所有的集合的不相交性。
** 路径压缩
   把树所存储的高度称为秩。
* 图论算法
* 算法设计技巧
* 摊还分析
* 高级数据结构及其实现

* FQA
