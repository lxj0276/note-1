#+OPTIONS: ^:nil、
* 简介
1. 算法：通俗而言，算法是一个定义明确的计算过程，可以一些值或一组值作为输入并产生一些值或一组值作为输出。因此算法就是将输入转为输出的一系列计算步骤。
2. 算法的三大特征：
   + 有限
   + 指令明确
   + 有效
* 数据结构与算法
  仅需要常量空间并以线性时间运行的联机算法几乎是完美的算法.
  对数出现的规律：如果一个算法用常数时间将问题的大小削减为其一部分（通常为 1/2）,那么算法就是 log(N).
  任何仅通过使用比较来进行排序的算法在最坏的情况下只需要 Omega(NlogN)次比较。
  gcd 算法(两个整数的最大公因数)和求幂算法应用在密码学中.
** tree
** graph
* 统治世界的十大算法
[[http://36kr.com/p/212499.html][统治世界的十大算法]]
1. 归并排序、快速排序及堆积排序
2. 傅里叶变换与快速傅里叶变换
3. 迪杰斯特拉（Dijkstra）算法
4. RSA 算法
5. 安全哈希算法（SHA）
6. 整数因子分解
7. 链接分析
8. 比例积分微分算法
9. 数据压缩算法
10. 随机数生成算法
* 排序算法
[[http://blog.csdn.net/xiazdong/article/details/8462393][九大排序算法再总结]]
[[http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/][经典排序算法总结与实现]]
[[https://zh.wikipedia.org/wiki/%25E6%258E%2592%25E5%25BA%258F%25E7%25AE%2597%25E6%25B3%2595][排序算法 维基百科]]
[[https://en.wikipedia.org/wiki/Sorting_algorithm][sorting algorithm wikipeida]]
时间复杂度, 空间复杂度, 稳定性.

*穩定性* ：穩定排序算法會讓原本有相等鍵值的紀錄維持相對次序。也就是如果一個排序算法是穩定的，當有兩個相等鍵值的紀錄 R 和 S，且在原本的串列中 R 出現在 S 之前，在排序過的串列中 R 也將會是在 S 之前。
不穩定排序算法可能會在相等的鍵值中改變紀錄的相對次序，但是穩定排序算法從來不會如此。
** 稳定的排序
*** 冒泡排序 Bubble Sort

#+BEGIN_SRC screen  
// 虚拟码
  function bubble_sort (array, length) {
      var i, j;
      for(i from 0 to length-1){
          for(j from 0 to length-1-i){
              if (array[j] > array[j+1])
                  swap(array[j], array[j+1])
          }
      }
  }
#+END_SRC


#+BEGIN_SRC java

    public static void bubble_sort(int[] arr) {
      int i, j, temp, len = arr.length;
      for (i = 0; i < len - 1; i++)
        for (j = 0; j < len - 1 - i; j++)
          if (arr[j] > arr[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
    }
#+END_SRC


#+BEGIN_SRC scala

    def bubbleSort(array: Array[Int]): Unit = {
      val len = array.length
      for (i <- 0 until len) {
        for (j <- 0 until len - i - 1) {
          if (array(j) > array(j + 1)){
            val temp = array(j)
            array(j) = array(j + 1)
            array(j + 1) = temp
          }
        }
      }
    }
#+END_SRC

* 机器学习十大算法简介
[[https://github.com/ty4z2008/Qix/blob/master/dl.md][机器学习(Machine Learning)&深度学习(Deep Learning)资料]]
* 动态规划(Dynamic programming) 求斐波那契
动态规划（英语：Dynamic programming，简称 DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。
动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

适用情况:
1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态規劃算法解决问题提供了重要线索。
2. 无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。
3. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态規劃算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。
#+BEGIN_SRC python
  values = {0: 0, 1: 1}

  def fib(n):
      if(not values.has_key(n)):
          value = {n: (fib(n-1) + fib(n-2))}
          values.update(value)
      return values.get(n)
#+END_SRC

* 背包问题
  [[https://zh.wikipedia.org/wiki/%25E8%2583%258C%25E5%258C%2585%25E9%2597%25AE%25E9%25A2%2598][背包问题{维基百科}]]
  背包问题（Knapsack problem）是一种组合优化的 NP 完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。
  也可以将背包问题描述为决定性问题，即在总重量不超过 W 的前提下，总价值是否能达到 V。
* dataesp
** DATAX-RAY ENSEMBLE
  图像处理器与机器学习结合，一个新的预测性智能分析领域将会被开启—图像识别。
  线性回归模型( Logistic Regression)、神经网络( Neural Networks)、限制玻尔兹曼机( Restricted Boltzmann Machines)
** DataX-ray Screening
平台运用包括奇异值分解、k 最近邻分析、关联规则挖掘在内的多种高级机器学习算法。
** DataX-ray Periscope
