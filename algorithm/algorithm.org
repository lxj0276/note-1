#+OPTIONS: ^:nil、
* 简介
1. 算法：通俗而言，算法是一个定义明确的计算过程，可以一些值或一组值作为输入并产生一些值或一组值作为输出。因此算法就是将输入转为输出的一系列计算步骤。
2. 算法的三大特征：
   + 有限
   + 指令明确
   + 有效
* 数据结构与算法
  仅需要常量空间并以线性时间运行的联机算法几乎是完美的算法.
  对数出现的规律：如果一个算法用常数时间将问题的大小削减为其一部分（通常为1/2）,那么算法就是log(N).
  任何仅通过使用比较来进行排序的算法在最坏的情况下只需要Omega(NlogN)次比较。
  gcd算法(两个整数的最大公因数)和求幂算法应用在密码学中.
  
* 统治世界的十大算法
[[http://36kr.com/p/212499.html][统治世界的十大算法]]
1. 归并排序、快速排序及堆积排序
2. 傅里叶变换与快速傅里叶变换
3. 迪杰斯特拉（Dijkstra）算法
4. RSA算法
5. 安全哈希算法（SHA）
6. 整数因子分解
7. 链接分析
8. 比例积分微分算法
9. 数据压缩算法
10. 随机数生成算法
* 排序算法
[[http://blog.csdn.net/xiazdong/article/details/8462393][九大排序算法再总结]]
[[http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/][经典排序算法总结与实现]]
[[https://zh.wikipedia.org/wiki/%25E6%258E%2592%25E5%25BA%258F%25E7%25AE%2597%25E6%25B3%2595][排序算法 维基百科]]
[[https://en.wikipedia.org/wiki/Sorting_algorithm][sorting algorithm wikipeida]]
时间复杂度, 空间复杂度, 稳定性.

*穩定性* ：穩定排序算法會讓原本有相等鍵值的紀錄維持相對次序。也就是如果一個排序算法是穩定的，當有兩個相等鍵值的紀錄R和S，且在原本的串列中R出現在S之前，在排序過的串列中R也將會是在S之前。
不穩定排序算法可能會在相等的鍵值中改變紀錄的相對次序，但是穩定排序算法從來不會如此。
** 稳定的排序
*** 冒泡排序 Bubble Sort
最差時間複雜度	O(n2)
最優時間複雜度	O(n)
平均時間複雜度	O(n2)
最差空間複雜度	总共O(n)，需要辅助空间O(1)

冒泡排序演算法的運作如下：

1. 比較相鄰的元素。如果第一個比第二個大，就交換他們兩個。
2. 對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。
3. 針對所有的元素重複以上的步驟，除了最後一個。
4. 持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。

#+BEGIN_SRC screen  
// 虚拟码
  function bubble_sort (array, length) {
      var i, j;
      for(i from 0 to length-1){
          for(j from 0 to length-1-i){
              if (array[j] > array[j+1])
                  swap(array[j], array[j+1])
          }
      }
  }
#+END_SRC

#+BEGIN_SRC java

    public static void bubble_sort(int[] arr) {
      int i, j, temp, len = arr.length;
      for (i = 0; i < len - 1; i++)
        for (j = 0; j < len - 1 - i; j++)
          if (arr[j] > arr[j + 1]) {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
          }
    }
#+END_SRC

#+BEGIN_SRC python

  def bubbleSort(A):
      n = len(A)
      for i in range(n):
          for j in range(1, n - i):  # 如果前者比后者大，交换数据
              if A[j-1] > A[j]:
                  A[j-1], A[j] = A[j], A[j-1]
      return A
#+END_SRC

#+BEGIN_SRC scala

    def bubbleSort(array: Array[Int]): Unit = {
      val len = array.length
      for (i <- 0 until len) {
        for (j <- 0 until len - i - 1) {
          if (array(j) > array(j + 1)){
            val temp = array(j)
            array(j) = array(j + 1)
            array(j + 1) = temp
          }
        }
      }
    }
#+END_SRC
*** 归并排序
**** 复杂度
Data structure:	Array
Worst case performance:	O(n log n)
Best case performance: O(n log n) typical, O(n) natural variant
Average case performance:	O(n log n)
Worst case space complexity:	О(n) total, O(n) auxiliary
**** 迭代法:
1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针到达序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾
**** 递归法
原理如下（假设序列共有n个元素）：

1. 将序列每相邻两个数字进行归并操作，形成floor(n/2)个序列，排序后每个序列包含两个元素
2. 将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素
3. 重复步骤2，直到所有元素排序完毕
**** 代码

#+BEGIN_SRC python
  from collections import deque

  def merge_sort1(lst):
  ''' use deque '''

      if len(lst) <= 1:
          return lst

      def merge(left, right):
          merged,left,right = deque(),deque(left),deque(right)
          while left and right:
              merged.append(left.popleft() if left[0] <= right[0] else right.popleft())  # deque popleft is also O(1)
          merged.extend(right if right else left)
          return list(merged)

      middle = int(len(lst) // 2)
      left = merge_sort(lst[:middle])
      right = merge_sort(lst[middle:])
      return merge(left, right)


  def merge_sort2(A):
      def merge(left, right):
          '''将两个有序序列left,right 合并成一个较大的序列'''
          result = []
          l, r = 0, 0
          while l < len(left) and r < len(right):
              if left[l] < right[r]:
                  result.append(left[l])
                  l = l + 1
              else:
                  result.append(right[r])
                  r = r + 1
          # 添加没有迭代完的(左边后者右边有一个没有迭代完)
          result = result + left[l:]
          result = result + right[r:]
          return result

      if len(A) <= 1:
          return A
      num = int(len(A)//2)  # 二分分解
      left = mergeSort(A[:num])
      right = mergeSort(A[num:])
      return merge(left, right)
#+END_SRC

#+BEGIN_SRC java
  /* 递归 */
  static void merge_sort_recursive(int[] arr, int[] reg, int start, int end) {
      if (start >= end)
          return;
      int len = end - start, mid = (len >> 1) + start;
      int start1 = start, end1 = mid;
      int start2 = mid + 1, end2 = end;
      merge_sort_recursive(arr, reg, start1, end1);
      merge_sort_recursive(arr, reg, start2, end2);
      int k = start;
      while (start1 <= end1 && start2 <= end2)
          reg[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
      while (start1 <= end1)
          reg[k++] = arr[start1++];
      while (start2 <= end2)
          reg[k++] = arr[start2++];
      for (k = start; k <= end; k++)
          arr[k] = reg[k];
  }
  public static void merge_sort(int[] arr) {
      int len = arr.length;
      int[] reg = new int[len];
      merge_sort_recursive(arr, reg, 0, len - 1);
  }

  /* 迭代　*/
  public static void merge_sort(int[] arr) {
      int len = arr.length;
      int[] result = new int[len];
      int block, start;
    
      for(block = 1; block < len ; block *= 2) {
          for(start = 0; start <len; start += 2 * block) {
              int low = start;
              int mid = (start + block) < len ? (start + block) : len;
              int high = (start + 2 * block) < len ? (start + 2 * block) : len;
              //两个块的起始下标及结束下标
              int start1 = low, end1 = mid;
              int start2 = mid, end2 = high;
              //开始对两个block进行归并排序
              while (start1 < end1 && start2 < end2) {
                  result[low++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
              }
              while(start1 < end1) {
                  result[low++] = arr[start1++];
              }
              while(start2 < end2) {
                  result[low++] = arr[start2++];
              }
          }
          int[] temp = arr;
          arr = result;
          result = temp;
      }
      result = arr;       
  }
#+END_SRC


*** 
** 不稳定的排序
*** 快速排序
快速排序（quick sort）—O(n log n)期望時間，O(n2)最壞情況；對於大的、亂數串列一般相信是最快的已知排序.
最差空間複雜度: 根據實現的方式不同而不同.

演算法:  \\
1. 從數列中挑出一個元素，稱為"基準"（pivot）
2. 重新排序數列，所有元素比基準值小的擺放在基準前面，所有元素比基準值大的擺在基準的後面（相同的數可以到任一邊）。在這個分割結束之後，該基準就處於數列的中間位置。這個稱為分割（partition）操作。
3. 递归地（recursive）把小於基准值元素的子數列和大於基准值元素的子數列排序。

   #+BEGIN_SRC python

     def quickSort(A):
         return quick(A, 0, len(A) - 1)


     def quick(B, left, right):
         # 快排函数，ary为待排序数组，left为待排序的左边界，right为右边界
         if left >= right:
             return B
         key = B[left]  # 取最左边的为基准
         lp = left  # 左指针
         rp = right  # 右指针
         while lp < rp:  # 从两边交替向中间扫描，直到lp=rp为止
             while B[rp] >= key and lp < rp:  # 必须从右边开始查找小于key的值，否则错误
                 rp = rp - 1
             while B[lp] <= key and lp < rp:
                 lp = lp + 1
             B[lp], B[rp] = B[rp], B[lp]

         B[left], B[lp] = B[lp], B[left]
         quick(B, left, lp-1)
         quick(B, rp+1, right)
         return B

   #+END_SRC

   #+BEGIN_SRC java
     class quick_sort {
         int[] arr;

         private void swap(int x, int y) {
             int temp = arr[x];
             arr[x] = arr[y];
             arr[y] = temp;
         }

         private void quick_sort_recursive(int start, int end) {
             if (start >= end)
                 return;
             int mid = arr[end];
             int left = start, right = end - 1;
             while (left < right) {
                 while (arr[left] < mid && left < right)
                     left++;
                 while (arr[right] >= mid && left < right)
                     right--;
                 swap(left, right);
             }
             if (arr[left] >= arr[end])
                 swap(left, end);
             else
                 left++;
             quick_sort_recursive(start, left - 1);
             quick_sort_recursive(left + 1, end);
         }

         public void sort(int[] arrin) {
             arr = arrin;
             quick_sort_recursive(0, arr.length - 1);
         }
     }
   #+END_SRC

   #+BEGIN_SRC scala
     def quick(arr: Array[Int]): Array[Int] = {
       if(arr.length <= 1) {
         return arr
       } else {
         val pivot = arr(0)
         val arrRemain = arr.slice(1, arr.length)
         val arrLeft = arrRemain.filter(_ < pivot)
         val arrRight = arrRemain.filter(_ >= pivot)
         return Array.concat(quick(arrLeft), Array(pivot), quick(arrRight))
       }
     }

   #+END_SRC

* 机器学习十大算法简介
[[https://github.com/ty4z2008/Qix/blob/master/dl.md][机器学习(Machine Learning)&深度学习(Deep Learning)资料]]
* dataesp
** DATAX-RAY ENSEMBLE
  图像处理器与机器学习结合，一个新的预测性智能分析领域将会被开启—图像识别。
  线性回归模型( Logistic Regression)、神经网络( Neural Networks)、限制玻尔兹曼机( Restricted Boltzmann Machines)
** DataX-ray Screening
平台运用包括奇异值分解、k最近邻分析、关联规则挖掘在内的多种高级机器学习算法。
** DataX-ray Periscope
