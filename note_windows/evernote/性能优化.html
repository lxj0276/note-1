<html>
<head>
  <title>性能优化</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272236; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="5599"/>
<h1>性能优化</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2014/8/19 22:26</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2014/8/28 0:48</i></td></tr>
<tr><td><b>标签：</b></td><td><i>抓取策略</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://docs.huihoo.com/hibernate/reference-v3_zh-cn/performance.html"><i>http://docs.huihoo.com/hibernate/reference-v3_zh-cn/performance.html</i></a></td></tr>
</table>
</div>
<br/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><h2>第 20 章 提升性能</h2></div><div lang="zh-cn"><div><h2 style="clear: both"><a name="performance-fetching"></a>20.1.  抓取策略(Fetching strategies)</h2></div><p><em>抓取策略（fetching strategy）</em> 是指：当应用程序需要在（Hibernate实体对象图的）关联关系间进行导航的时候， Hibernate如何获取关联对象的策略。抓取策略可以在O/R映射的元数据中声明，也可以在特定的HQL 或<tt>条件查询（Criteria Query）</tt>中重载声明。</p><p>Hibernate3 定义了如下几种抓取策略：</p><div><ul type="disc"><li><p><em>连接抓取（Join fetching）</em> - Hibernate通过 在<tt>SELECT</tt>语句使用<tt>OUTER JOIN</tt>（外连接）来 获得对象的关联实例或者关联集合。</p></li><li><p><em>查询抓取（Select fetching）</em> - 另外发送一条 <tt>SELECT</tt> 语句抓取当前对象的关联实体或集合。除非你显式的指定<tt>lazy=&quot;false&quot;</tt>禁止 延迟抓取（lazy fetching），否则只有当你真正访问关联关系的时候，才会执行第二条select语句。</p></li><li><p><em>子查询抓取（Subselect fetching）</em> - 另外发送一条<tt>SELECT</tt> 语句抓取在前面查询到（或者抓取到）的所有实体对象的关联集合。除非你显式的指定<tt>lazy=&quot;false&quot;</tt> 禁止延迟抓取（lazy fetching），否则只有当你真正访问关联关系的时候，才会执行第二条select语句。</p></li><li><p><em>批量抓取（Batch fetching）</em> - 对查询抓取的优化方案， 通过指定一个主键或外键列表，Hibernate使用单条<tt>SELECT</tt>语句获取一批对象实例或集合。</p></li></ul></div><p>Hibernate会区分下列各种情况：</p><div><ul type="disc"><li><p><em>Immediate fetching，立即抓取</em> - 当宿主被加载时，关联、集合或属性被立即抓取。</p></li><li><p><em>Lazy collection fetching，延迟集合抓取</em>- 直到应用程序对集合进行了一次操作时，集合才被抓取。（对集合而言这是默认行为。）</p></li><li><p><em>Proxy fetching，代理抓取</em> - 对返回单值的关联而言，当其某个方法被调用，而非对其关键字进行get操作时才抓取。</p></li><li><p><em>Lazy attribute fetching，属性延迟加载</em> - 对属性或返回单值的关联而言，当其实例变量被访问的时候进行抓取（需要运行时字节码强化）。这一方法很少是必要的。</p></li></ul></div><p>这里有两个正交的概念：关联<em>何时</em>被抓取，以及被<em>如何</em>抓取（会采用什么样的SQL语句）。不要混淆它们！我们使用<tt>抓取</tt>来改善性能。我们使用<tt>延迟</tt>来定义一些契约，对某特定类的某个脱管的实例，知道有哪些数据是可以使用的。</p><div lang="zh-cn"><div><h3><a name="performance-fetching-lazy"></a>20.1.1. 操作延迟加载的关联</h3></div><p>默认情况下，Hibernate 3对集合使用延迟select抓取，对返回单值的关联使用延迟代理抓取。对几乎是所有的应用而言，其绝大多数的关联，这种策略都是有效的。</p><p><em>注意:</em>假若你设置了<tt>hibernate.default_batch_fetch_size</tt>,Hibernate会对延迟加载采取批量抓取优化措施（这种优化也可能会在更细化的级别打开）。</p><p>然而，你必须了解延迟抓取带来的一个问题。在一个打开的Hibernate session上下文之外调用延迟集合会导致一次意外。比如：</p><pre>
s = sessions.openSession();
Transaction tx = s.beginTransaction();
            
User u = (User) s.createQuery(&quot;from User u where u.name=:userName&quot;)
        .setString(&quot;userName&quot;, userName).uniqueResult();
Map permissions = u.getPermissions();

tx.commit();
s.close();

Integer accessLevel = (Integer) permissions.get(&quot;accounts&quot;);  // Error!
</pre><p>在<tt>Session</tt>关闭后，permessions集合将是未实例化的、不再可用，因此无法正常载入其状态。 <em>Hibernate对脱管对象不支持延迟实例化</em>. 这里的修改方法是：将permissions读取数据的代码 移到tx.commit()之前。</p><p>除此之外，通过对关联映射指定<tt>lazy=&quot;false&quot;</tt>,我们也可以使用非延迟的集合或关联。但是， 对绝大部分集合来说，更推荐使用延迟方式抓取数据。如果在你的对象模型中定义了太多的非延迟关联，Hibernate最终几乎需要在每个事务中载入整个数据库到内存中！</p><p>但是，另一方面，在一些特殊的事务中，我们也经常需要使用到连接抓取（它本身上就是非延迟的），以代替查询抓取。 下面我们将会很快明白如何具体的定制Hibernate中的抓取策略。在Hibernate3中，具体选择哪种抓取策略的机制是和选择 单值关联或集合关联相一致的。</p></div><div lang="zh-cn"><div><h3><a name="performance-fetching-custom"></a>20.1.2.  调整抓取策略（Tuning fetch strategies）</h3></div><p>查询抓取（默认的）在N+1查询的情况下是极其脆弱的，因此我们可能会要求在映射文档中定义使用连接抓取：</p><pre>
&lt;set name=&quot;permissions&quot; 
            fetch=&quot;join&quot;&gt;
    &lt;key column=&quot;userId&quot;/&gt;
    &lt;one-to-many class=&quot;Permission&quot;/&gt;
&lt;/set
</pre><pre>
&lt;many-to-one name=&quot;mother&quot; class=&quot;Cat&quot; fetch=&quot;join&quot;/&gt;
</pre><p>在映射文档中定义的抓取策略将会有产生以下影响：</p><div><ul type="disc"><li><p>通过<tt>get()</tt>或<tt>load()</tt>方法取得数据。</p></li><li><p>只有在关联之间进行导航时，才会隐式的取得数据(延迟抓取)。</p></li><li><p><tt>条件查询</tt></p></li></ul></div><p>通常情况下，我们并不使用映射文档进行抓取策略的定制。更多的是，保持其默认值，然后在特定的事务中， 使用HQL的<tt>左连接抓取（left join fetch）</tt> 对其进行重载。这将通知 Hibernate在第一次查询中使用外部关联（outer join），直接得到其关联数据。 在<tt>条件查询</tt> API中，应该调用 <tt>setFetchMode(FetchMode.JOIN)</tt>语句。</p><p>也许你喜欢仅仅通过条件查询，就可以改变<tt>get()</tt> 或 <tt>load()</tt>语句中的数据抓取策略。例如：</p><pre>
User user = (User) session.createCriteria(User.class)
                .setFetchMode(&quot;permissions&quot;, FetchMode.JOIN)
                .add( Restrictions.idEq(userId) )
                .uniqueResult();
</pre><p>（这就是其他ORM解决方案的“抓取计划(fetch plan)”在Hibernate中的等价物。）</p><p>截然不同的一种避免N+1次查询的方法是，使用二级缓存。</p></div><div lang="zh-cn"><div><h3><a name="performance-fetching-proxies"></a>20.1.3. 单端关联代理（Single-ended association proxies）</h3></div><p>在Hinerbate中，对集合的延迟抓取的采用了自己的实现方法。但是，对于单端关联的延迟抓取，则需要采用 其他不同的机制。单端关联的目标实体必须使用代理，Hihernate在运行期二进制级（通过优异的CGLIB库）， 为持久对象实现了延迟载入代理。</p><p>默认的，Hibernate3将会为所有的持久对象产生代理（在启动阶段），然后使用他们实现 <tt>多对一（many-to-one）</tt>关联和<tt>一对一（one-to-one）</tt> 关联的延迟抓取。</p><p>在映射文件中，可以通过设置<tt>proxy</tt>属性为目标class声明一个接口供代理接口使用。 默认的，Hibernate将会使用该类的一个子类。 <em>注意：被代理的类必须实现一个至少包可见的默认构造函数，我们建议所有的持久类都应拥有这样的构造函数</em></p><p>在如此方式定义一个多态类的时候，有许多值得注意的常见性的问题，例如：</p><pre>
&lt;class name=&quot;Cat&quot; proxy=&quot;Cat&quot;&gt;
    ......
    &lt;subclass name=&quot;DomesticCat&quot;&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;
</pre><p>首先，<tt>Cat</tt>实例永远不可以被强制转换为<tt>DomesticCat</tt>, 即使它本身就是<tt>DomesticCat</tt>实例。</p><pre>
Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)
if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy
    DomesticCat dc = (DomesticCat) cat;       // Error!
    ....
}
</pre><p>其次，代理的“<tt>==</tt>”可能不再成立。</p><pre>
Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy
DomesticCat dc = 
        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!
System.out.println(cat==dc);                            // false
</pre><p>虽然如此，但实际情况并没有看上去那么糟糕。虽然我们现在有两个不同的引用，分别指向这两个不同的代理对象， 但实际上，其底层应该是同一个实例对象：</p><pre>
cat.setWeight(11.0);  // hit the db to initialize the proxy
System.out.println( dc.getWeight() );  // 11.0
</pre><p>第三，你不能对“final类”或“具有final方法的类”使用CGLIB代理。</p><p>最后，如果你的持久化对象在实例化时需要某些资源（例如，在实例化方法、默认构造方法中）， 那么代理对象也同样需要使用这些资源。实际上，代理类是持久化类的子类。</p><p>这些问题都源于Java的单根继承模型的天生限制。如果你希望避免这些问题，那么你的每个持久化类必须实现一个接口， 在此接口中已经声明了其业务方法。然后，你需要在映射文档中再指定这些接口。例如：</p><pre>
&lt;class name=&quot;CatImpl&quot; proxy=&quot;Cat&quot;&gt;
    ......
    &lt;subclass name=&quot;DomesticCatImpl&quot; proxy=&quot;DomesticCat&quot;&gt;
        .....
    &lt;/subclass&gt;
&lt;/class&gt;
</pre><p>这里<tt>CatImpl</tt>实现了<tt>Cat</tt>接口， <tt>DomesticCatImpl</tt>实现<tt>DomesticCat</tt>接口。 在<tt>load()</tt>、<tt>iterate()</tt>方法中就会返回 <tt>Cat</tt>和<tt>DomesticCat</tt>的代理对象。 (注意<tt>list()</tt>并不会返回代理对象。)</p><pre>
Cat cat = (Cat) session.load(CatImpl.class, catid);
Iterator iter = session.iterate(&quot;from CatImpl as cat where cat.name='fritz'&quot;);
Cat fritz = (Cat) iter.next();
</pre><p>这里，对象之间的关系也将被延迟载入。这就意味着，你应该将属性声明为<tt>Cat</tt>，而不是<tt>CatImpl</tt>。</p><p>但是，在有些方法中是<em>不需要</em>使用代理的。例如：</p><div><ul compact="compact" type="disc"><li><p><tt>equals()</tt>方法，如果持久类没有重载<tt>equals()</tt>方法。</p></li><li><p><tt>hashCode()</tt>方法，如果持久类没有重载<tt>hashCode()</tt>方法。</p></li><li><p>标志符的getter方法。</p></li></ul></div><p>Hibernate将会识别出那些重载了<tt>equals()</tt>、或<tt>hashCode()</tt>方法的持久化类。</p></div><div lang="zh-cn"><div><h3><a name="performance-fetching-initialization"></a>20.1.4. 实例化集合和代理（Initializing collections and proxies）</h3></div><p>在<tt>Session</tt>范围之外访问未初始化的集合或代理，Hibernate将会抛出<tt>LazyInitializationException</tt>异常。 也就是说，在分离状态下，访问一个实体所拥有的集合，或者访问其指向代理的属性时，会引发此异常。</p><p>有时候我们需要保证某个代理或者集合在Session关闭前就已经被初始化了。 当然，我们可以通过强行调用<tt>cat.getSex()</tt>或者<tt>cat.getKittens().size()</tt>之类的方法来确保这一点。 但是这样的程序会造成读者的疑惑，也不符合通常的代码规范。</p><p>静态方法<tt>Hibernate.initialized()</tt> 为你的应用程序提供了一个便捷的途径来延迟加载集合或代理。 只要它的Session处于open状态，<tt>Hibernate.initialize(cat)</tt> 将会为cat强制对代理实例化。 同样，<tt>Hibernate.initialize( cat.getKittens() )</tt> 对kittens的集合具有同样的功能。</p><p>还有另外一种选择，就是保持<tt>Session</tt>一直处于open状态，直到所有需要的集合或代理都被载入。 在某些应用架构中，特别是对于那些使用Hibernate进行数据访问的代码，以及那些在不同应用层和不同物理进程中使用Hibernate的代码。 在集合实例化时，如何保证<tt>Session</tt>处于open状态经常会是一个问题。有两种方法可以解决此问题：</p><div><ul type="disc"><li><p>在一个基于Web的应用中，可以利用servlet过滤器（filter），在用户请求（request）结束、页面生成 结束时关闭<tt>Session</tt>（这里使用了<em>在展示层保持打开Session模式（Open Session in View）</em>）， 当然，这将依赖于应用框架中异常需要被正确的处理。在返回界面给用户之前，乃至在生成界面过程中发生异常的情况下， 正确关闭<tt>Session</tt>和结束事务将是非常重要的， Servlet过滤器必须如此访问<tt>Session</tt>，才能保证正确使用Session。 我们推荐使用<tt>ThreadLocal</tt> 变量保存当前的<tt>Session</tt> （可以参考<a href="http://docs.huihoo.com/hibernate/reference-v3_zh-cn/quickstart.html#quickstart-playingwithcats" title="1.4.&amp;amp;nbsp;与Cat同乐">第 1.4 节 “与Cat同乐”</a>的例子实现）。</p></li><li><p>在一个拥有单独业务层的应用中，业务层必须在返回之前，为web层“准备”好其所需的数据集合。这就意味着 业务层应该载入所有表现层/web层所需的数据，并将这些已实例化完毕的数据返回。通常，应用程序应该 为web层所需的每个集合调用<tt>Hibernate.initialize()</tt>（这个调用必须发生咱session关闭之前）； 或者使用带有<tt>FETCH</tt>从句，或<tt>FetchMode.JOIN</tt>的Hibernate查询， 事先取得所有的数据集合。如果你在应用中使用了<em>Command</em>模式，代替<em>Session Facade</em> ， 那么这项任务将会变得简单的多。</p></li><li><p>你也可以通过<tt>merge()</tt>或<tt>lock()</tt>方法，在访问未实例化的集合（或代理）之前， 为先前载入的对象绑定一个新的<tt>Session</tt>。 显然，Hibernate将不会，也不<em>应该</em>自动完成这些任务，因为这将引入一个特殊的事务语义。</p></li></ul></div><p>有时候，你并不需要完全实例化整个大的集合，仅需要了解它的部分信息（例如其大小）、或者集合的部分内容。</p><p>你可以使用集合过滤器得到其集合的大小，而不必实例化整个集合：</p><pre>
( (Integer) s.createFilter( collection, &quot;select count(*)&quot; ).list().get(0) ).intValue()
</pre><p>这里的<tt>createFilter()</tt>方法也可以被用来有效的抓取集合的部分内容，而无需实例化整个集合：</p><pre>
s.createFilter( lazyCollection, &quot;&quot;).setFirstResult(0).setMaxResults(10).list();
</pre></div><div lang="zh-cn"><div><h3><a name="performance-fetching-batch"></a>20.1.5. 使用批量抓取（Using batch fetching）</h3></div><p>Hibernate可以充分有效的使用批量抓取，也就是说，如果仅一个访问代理（或集合），那么Hibernate将不载入其他未实例化的代理。 批量抓取是延迟查询抓取的优化方案，你可以在两种批量抓取方案之间进行选择：在类级别和集合级别。</p><p>类/实体级别的批量抓取很容易理解。假设你在运行时将需要面对下面的问题：你在一个<tt>Session</tt>中载入了25个 <tt>Cat</tt>实例，每个<tt>Cat</tt>实例都拥有一个引用成员<tt>owner</tt>， 其指向<tt>Person</tt>，而<tt>Person</tt>类是代理，同时<tt>lazy=&quot;true&quot;</tt>。 如果你必须遍历整个cats集合，对每个元素调用<tt>getOwner()</tt>方法，Hibernate将会默认的执行25次<tt>SELECT</tt>查询， 得到其owner的代理对象。这时，你可以通过在映射文件的<tt>Person</tt>属性，显式声明<tt>batch-size</tt>，改变其行为：</p><pre>
&lt;class name=&quot;Person&quot; batch-size=&quot;10&quot;&gt;...&lt;/class&gt;
</pre><p>随之，Hibernate将只需要执行三次查询，分别为10、10、 5。</p><p>你也可以在集合级别定义批量抓取。例如，如果每个<tt>Person</tt>都拥有一个延迟载入的<tt>Cats</tt>集合， 现在，<tt>Sesssion</tt>中载入了10个person对象，遍历person集合将会引起10次<tt>SELECT</tt>查询， 每次查询都会调用<tt>getCats()</tt>方法。如果你在<tt>Person</tt>的映射定义部分，允许对<tt>cats</tt>批量抓取, 那么，Hibernate将可以预先抓取整个集合。请看例子：</p><pre>
&lt;class name=&quot;Person&quot;&gt;
    &lt;set name=&quot;cats&quot; batch-size=&quot;3&quot;&gt;
        ...
    &lt;/set&gt;
&lt;/class&gt;
</pre><p>如果整个的<tt>batch-size</tt>是3（笔误？），那么Hibernate将会分四次执行<tt>SELECT</tt>查询， 按照3、3、3、1的大小分别载入数据。这里的每次载入的数据量还具体依赖于当前<tt>Session</tt>中未实例化集合的个数。</p><p>如果你的模型中有嵌套的树状结构，例如典型的帐单－原料结构（bill-of-materials pattern），集合的批量抓取是非常有用的。 （尽管在更多情况下对树进行读取时，<em>嵌套集合（nested set）</em>或<em>原料路径(materialized path)</em>（××） 是更好的解决方法。）</p></div><div lang="zh-cn"><div><h3><a name="performance-fetching-subselect"></a>20.1.6. 使用子查询抓取（Using subselect fetching）</h3></div><p>假若一个延迟集合或单值代理需要抓取，Hibernate会使用一个subselect重新运行原来的查询，一次性读入所有的实例。这和批量抓取的实现方法是一样的，不会有破碎的加载。</p></div><div lang="zh-cn"><div><h3><a name="performance-fetching-lazyproperties"></a>20.1.7. 使用延迟属性抓取（Using lazy property fetching）</h3></div><p>Hibernate3对单独的属性支持延迟抓取，这项优化技术也被称为<em>组抓取（fetch groups）</em>。 请注意，该技术更多的属于市场特性。在实际应用中，优化行读取比优化列读取更重要。但是，仅载入类的部分属性在某些特定情况下会有用，例如在原有表中拥有几百列数据、数据模型无法改动的情况下。</p><p>可以在映射文件中对特定的属性设置<tt>lazy</tt>，定义该属性为延迟载入。</p><pre>
&lt;class name=&quot;Document&quot;&gt;
       &lt;id name=&quot;id&quot;&gt;
        &lt;generator class=&quot;native&quot;/&gt;
    &lt;/id&gt;
    &lt;property name=&quot;name&quot; not-null=&quot;true&quot; length=&quot;50&quot;/&gt;
    &lt;property name=&quot;summary&quot; not-null=&quot;true&quot; length=&quot;200&quot; lazy=&quot;true&quot;/&gt;
    &lt;property name=&quot;text&quot; not-null=&quot;true&quot; length=&quot;2000&quot; lazy=&quot;true&quot;/&gt;
&lt;/class&gt;
</pre><p>属性的延迟载入要求在其代码构建时加入二进制指示指令（bytecode instrumentation），如果你的持久类代码中未含有这些指令， Hibernate将会忽略这些属性的延迟设置，仍然将其直接载入。</p><p>你可以在Ant的Task中，进行如下定义，对持久类代码加入“二进制指令。”</p><pre>
&lt;target name=&quot;instrument&quot; depends=&quot;compile&quot;&gt;
    &lt;taskdef name=&quot;instrument&quot; classname=&quot;org.hibernate.tool.instrument.InstrumentTask&quot;&gt;
        &lt;classpath path=&quot;${jar.path}&quot;/&gt;
        &lt;classpath path=&quot;${classes.dir}&quot;/&gt;
        &lt;classpath refid=&quot;lib.class.path&quot;/&gt;
    &lt;/taskdef&gt;

    &lt;instrument verbose=&quot;true&quot;&gt;
        &lt;fileset dir=&quot;${testclasses.dir}/org/hibernate/auction/model&quot;&gt;
            &lt;include name=&quot;*.class&quot;/&gt;
        &lt;/fileset&gt;
    &lt;/instrument&gt;
&lt;/target&gt;
</pre><p>还有一种可以优化的方法，它使用HQL或条件查询的投影（projection）特性，可以避免读取非必要的列， 这一点至少对只读事务是非常有用的。它无需在代码构建时“二进制指令”处理，因此是一个更加值得选择的解决方法。</p><p>有时你需要在HQL中通过<tt>抓取所有属性</tt>，强行抓取所有内容。</p></div></div><div lang="zh-cn"><div><h2 style="clear: both"><a name="performance-cache"></a>20.2. 二级缓存（The Second Level Cache）</h2></div><p>Hibernate的<tt>Session</tt>在事务级别进行持久分化数据的缓存操作。 当然，也有可能别为每个类（或集合)，配置集群、或JVM级别(<tt>SessionFactory级别</tt>)的缓存。 你甚至可以为之插入一个集群的缓存。注意，缓存永远不知道其他应用程序对持久化仓库（数据库）可能进行的修改 （即使可以将缓存数据设定为定期失效）。</p><p>默认情况下，Hibernate使用EHCache进行JVM级别的缓存（目前，Hibernate已经废弃了对JCS的支持，未来版本中将会去掉它）。 你可以通过设置<tt>hibernate.cache.provider_class</tt>属性，指定其他的缓存策略， 该缓存策略必须实现<tt>org.hibernate.cache.CacheProvider</tt>接口。</p><div><a name="cacheproviders"></a><p><b>表 20.1.  缓存策略提供商（Cache Providers）</b></p><table border="1" summary="缓存策略提供商（Cache Providers）"><colgroup><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col></colgroup><thead><tr><th align="left">Cache</th><th align="left">Provider class</th><th align="left">Type</th><th align="left">Cluster Safe</th><th align="left">Query Cache Supported</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left"><tt>org.hibernate.cache.HashtableCacheProvider</tt></td><td align="left">memory</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">EHCache</td><td align="left"><tt>org.hibernate.cache.EhCacheProvider</tt></td><td align="left">memory, disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">OSCache</td><td align="left"><tt>org.hibernate.cache.OSCacheProvider</tt></td><td align="left">memory, disk</td><td align="left"> </td><td align="left">yes</td></tr><tr><td align="left">SwarmCache</td><td align="left"><tt>org.hibernate.cache.SwarmCacheProvider</tt></td><td align="left">clustered (ip multicast)</td><td align="left">yes (clustered invalidation)</td><td align="left"> </td></tr><tr><td align="left">JBoss TreeCache</td><td align="left"><tt>org.hibernate.cache.TreeCacheProvider</tt></td><td align="left">clustered (ip multicast), transactional</td><td align="left">yes (replication)</td><td align="left">yes (clock sync req.)</td></tr></tbody></table></div><div lang="zh-cn"><div><h3><a name="performance-cache-mapping"></a>20.2.1. 缓存映射（Cache mappings）</h3></div><p>类或者集合映射的“<tt>&lt;cache&gt;</tt>元素”可以有下列形式：</p><div><pre>
&lt;cache 
    usage=&quot;transactional|read-write|nonstrict-read-write|read-only&quot;  (1)
/&gt;
</pre><div><table border="0" summary="Callout list"><tbody><tr><td align="left" valign="top" width="5%">(1)</td><td align="left" valign="top"><p><tt>usage</tt>说明了缓存的策略: <tt>transactional</tt>、 <tt>read-write</tt>、 <tt>nonstrict-read-write</tt>或 <tt>read-only</tt>。</p></td></tr></tbody></table></div></div><p>另外(首选?), 你可以在hibernate.cfg.xml中指定<tt>&lt;class-cache&gt;</tt>和 <tt>&lt;collection-cache&gt;</tt> 元素。</p><p>这里的<tt>usage</tt> 属性指明了<em>缓存并发策略（cache concurrency strategy）</em>。</p></div><div lang="zh-cn"><div><h3><a name="performance-cache-readonly"></a>20.2.2. 策略：只读缓存（Strategy: read only）</h3></div><p>如果你的应用程序只需读取一个持久化类的实例，而无需对其修改， 那么就可以对其进行<tt>只读</tt> 缓存。这是最简单，也是实用性最好的方法。甚至在集群中，它也能完美地运作。</p><pre>
&lt;class name=&quot;eg.Immutable&quot; mutable=&quot;false&quot;&gt;
    &lt;cache usage=&quot;read-only&quot;/&gt;
    ....
&lt;/class&gt;
</pre></div><div lang="zh-cn"><div><h3><a name="performance-cache-readwrite"></a>20.2.3.  策略:读/写缓存（Strategy: read/write）</h3></div><p>如果应用程序需要更新数据，那么使用<tt>读/写缓存</tt> 比较合适。 如果应用程序要求“序列化事务”的隔离级别（serializable transaction isolation level），那么就决不能使用这种缓存策略。 如果在JTA环境中使用缓存，你必须指定<tt>hibernate.transaction.manager_lookup_class</tt>属性的值， 通过它，Hibernate才能知道该应用程序中JTA的<tt>TransactionManager</tt>的具体策略。 在其它环境中，你必须保证在<tt>Session.close()</tt>、或<tt>Session.disconnect()</tt>调用前， 整个事务已经结束。 如果你想在集群环境中使用此策略，你必须保证底层的缓存实现支持锁定(locking)。Hibernate内置的缓存策略并不支持锁定功能。</p><pre>
&lt;class name=&quot;eg.Cat&quot; .... &gt;
    &lt;cache usage=&quot;read-write&quot;/&gt;
    ....
    &lt;set name=&quot;kittens&quot; ... &gt;
        &lt;cache usage=&quot;read-write&quot;/&gt;
        ....
    &lt;/set&gt;
&lt;/class&gt;
</pre></div><div lang="zh-cn"><div><h3><a name="performance-cache-nonstrict"></a>20.2.4.  策略:非严格读/写缓存（Strategy: nonstrict read/write）</h3></div><p>如果应用程序只偶尔需要更新数据（也就是说，两个事务同时更新同一记录的情况很不常见），也不需要十分严格的事务隔离， 那么比较适合使用<tt>非严格读/写缓存</tt>策略。如果在JTA环境中使用该策略， 你必须为其指定<tt>hibernate.transaction.manager_lookup_class</tt>属性的值， 在其它环境中，你必须保证在<tt>Session.close()</tt>、或<tt>Session.disconnect()</tt>调用前， 整个事务已经结束。</p></div><div lang="zh-cn"><div><h3><a name="performance-cache-transactional"></a>20.2.5.  策略:事务缓存（transactional）</h3></div><p>Hibernate的<tt>事务缓存</tt>策略提供了全事务的缓存支持， 例如对JBoss TreeCache的支持。这样的缓存只能用于JTA环境中，你必须指定 为其<tt>hibernate.transaction.manager_lookup_class</tt>属性。</p></div><p>没有一种缓存提供商能够支持上列的所有缓存并发策略。下表中列出了各种提供器、及其各自适用的并发策略。</p><div><a name="d0e13479"></a><p><b>表 20.2.  各种缓存提供商对缓存并发策略的支持情况（Cache Concurrency Strategy Support）</b></p><table border="1" summary="各种缓存提供商对缓存并发策略的支持情况（Cache Concurrency Strategy Support）"><colgroup><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col><col align="left"></col></colgroup><thead><tr><th align="left">Cache</th><th align="left">read-only</th><th align="left">nonstrict-read-write</th><th align="left">read-write</th><th align="left">transactional</th></tr></thead><tbody><tr><td align="left">Hashtable (not intended for production use)</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">EHCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">OSCache</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td></tr><tr><td align="left">SwarmCache</td><td align="left">yes</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td></tr><tr><td align="left">JBoss TreeCache</td><td align="left">yes</td><td align="left"> </td><td align="left"> </td><td align="left">yes</td></tr></tbody></table></div></div><div lang="zh-cn"><div><h2 style="clear: both"><a name="performance-sessioncache"></a>20.3.  管理缓存（Managing the caches）</h2></div><p>无论何时，当你给<tt>save()</tt>、<tt>update()</tt>或 <tt>saveOrUpdate()</tt>方法传递一个对象时，或使用<tt>load()</tt>、 <tt>get()</tt>、<tt>list()</tt>、<tt>iterate()</tt> 或<tt>scroll()</tt>方法获得一个对象时, 该对象都将被加入到<tt>Session</tt>的内部缓存中。</p><p>当随后flush()方法被调用时，对象的状态会和数据库取得同步。 如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用<tt>evict()</tt> 方法，从一级缓存中去掉这些对象及其集合。</p><pre>
ScrollableResult cats = sess.createQuery(&quot;from Cat as cat&quot;).scroll(); //a huge result set
while ( cats.next() ) {
    Cat cat = (Cat) cats.get(0);
    doSomethingWithACat(cat);
    sess.evict(cat);
}
</pre><p>Session还提供了一个<tt>contains()</tt>方法，用来判断某个实例是否处于当前session的缓存中。</p><p>如若要把所有的对象从session缓存中彻底清除，则需要调用<tt>Session.clear()</tt>。</p><p>对于二级缓存来说，在<tt>SessionFactory</tt>中定义了许多方法， 清除缓存中实例、整个类、集合实例或者整个集合。</p><pre>
sessionFactory.evict(Cat.class, catId); //evict a particular Cat
sessionFactory.evict(Cat.class);  //evict all Cats
sessionFactory.evictCollection(&quot;Cat.kittens&quot;, catId); //evict a particular collection of kittens
sessionFactory.evictCollection(&quot;Cat.kittens&quot;); //evict all kitten collections
</pre><p><tt>CacheMode</tt>参数用于控制具体的Session如何与二级缓存进行交互。</p><div><ul type="disc"><li><p><tt>CacheMode.NORMAL</tt> - 从二级缓存中读、写数据。</p></li><li><p><tt>CacheMode.GET</tt> - 从二级缓存中读取数据，仅在数据更新时对二级缓存写数据。</p></li><li><p><tt>CacheMode.PUT</tt> - 仅向二级缓存写数据，但不从二级缓存中读数据。</p></li><li><p><tt>CacheMode.REFRESH</tt> - 仅向二级缓存写数据，但不从二级缓存中读数据。通过 <tt>hibernate.cache.use_minimal_puts</tt>的设置，强制二级缓存从数据库中读取数据，刷新缓存内容。</p></li></ul></div><p>如若需要查看二级缓存或查询缓存区域的内容，你可以使用<tt>统计（Statistics）</tt> API。</p><pre>
Map cacheEntries = sessionFactory.getStatistics()
        .getSecondLevelCacheStatistics(regionName)
        .getEntries();
</pre><p>此时，你必须手工打开统计选项。可选的，你可以让Hibernate更人工可读的方式维护缓存内容。</p><pre>
hibernate.generate_statistics true
hibernate.cache.use_structured_entries true
</pre></div><div lang="zh-cn"><div><h2 style="clear: both"><a name="performance-querycache"></a>20.4. 查询缓存（The Query Cache）</h2></div><p>查询的结果集也可以被缓存。只有当经常使用同样的参数进行查询时，这才会有些用处。 要使用查询缓存，首先你必须打开它：</p><pre>
hibernate.cache.use_query_cache true
</pre><p>该设置将会创建两个缓存区域 - 一个用于保存查询结果集(<tt>org.hibernate.cache.StandardQueryCache</tt>)； 另一个则用于保存最近查询的一系列表的时间戳(<tt>org.hibernate.cache.UpdateTimestampsCache</tt>)。 请注意：在查询缓存中，它并不缓存结果集中所包含的实体的确切状态；它只缓存这些实体的标识符属性的值、以及各值类型的结果。 所以查询缓存通常会和二级缓存一起使用。</p><p>绝大多数的查询并不能从查询缓存中受益，所以Hibernate默认是不进行查询缓存的。如若需要进行缓存，请调用 <tt>Query.setCacheable(true)</tt>方法。这个调用会让查询在执行过程中时先从缓存中查找结果， 并将自己的结果集放到缓存中去。</p><p>如果你要对查询缓存的失效政策进行精确的控制，你必须调用<tt>Query.setCacheRegion()</tt>方法， 为每个查询指定其命名的缓存区域。</p><pre>
List blogs = sess.createQuery(&quot;from Blog blog where blog.blogger = :blogger&quot;)
    .setEntity(&quot;blogger&quot;, blogger)
    .setMaxResults(15)
    .setCacheable(true)
    .setCacheRegion(&quot;frontpages&quot;)
    .list();
</pre><p>如果查询需要强行刷新其查询缓存区域，那么你应该调用<tt>Query.setCacheMode(CacheMode.REFRESH)</tt>方法。 这对在其他进程中修改底层数据（例如，不通过Hibernate修改数据），或对那些需要选择性更新特定查询结果集的情况特别有用。 这是对<tt>SessionFactory.evictQueries()</tt>的更为有效的替代方案，同样可以清除查询缓存区域。</p></div><div lang="zh-cn"><div><h2 style="clear: both"><a name="performance-collections"></a>20.5.  理解集合性能（Understanding Collection performance）</h2></div><p>前面我们已经对集合进行了足够的讨论。本段中，我们将着重讲述集合在运行时的事宜。</p><div lang="zh-cn"><div><h3><a name="performance-collections-taxonomy"></a>20.5.1.  分类（Taxonomy）</h3></div><p>Hibernate定义了三种基本类型的集合：</p><div><ul type="disc"><li><p>值数据集合</p></li><li><p>一对多关联</p></li><li><p>多对多关联</p></li></ul></div><p>这个分类是区分了不同的表和外键关系类型，但是它没有告诉我们关系模型的所有内容。 要完全理解他们的关系结构和性能特点，我们必须同时考虑“用于Hibernate更新或删除集合行数据的主键的结构”。 因此得到了如下的分类：</p><div><ul type="disc"><li><p>有序集合类</p></li><li><p>集合（sets）</p></li><li><p>包（bags)</p></li></ul></div><p>所有的有序集合类（maps, lists, arrays)都拥有一个由<tt>&lt;key&gt;</tt>和 <tt>&lt;index&gt;</tt>组成的主键。 这种情况下集合类的更新是非常高效的——主键已经被有效的索引，因此当Hibernate试图更新或删除一行时，可以迅速找到该行数据。</p><p>集合(sets)的主键由<tt>&lt;key&gt;</tt>和其他元素字段构成。 对于有些元素类型来说，这很低效，特别是组合元素或者大文本、大二进制字段； 数据库可能无法有效的对复杂的主键进行索引。 另一方面，对于一对多、多对多关联，特别是合成的标识符来说，集合也可以达到同样的高效性能。（ 附注：如果你希望<tt>SchemaExport</tt>为你的<tt>&lt;set&gt;</tt>创建主键， 你必须把所有的字段都声明为<tt>not-null=&quot;true&quot;</tt>。）</p><p><tt>&lt;idbag&gt;</tt>映射定义了代理键，因此它总是可以很高效的被更新。事实上， <tt>&lt;idbag&gt;</tt>拥有着最好的性能表现。</p><p>Bag是最差的。因为bag允许重复的元素值，也没有索引字段，因此不可能定义主键。 Hibernate无法判断出重复的行。当这种集合被更改时，Hibernate将会先完整地移除 （通过一个(in a single <tt>DELETE</tt>)）整个集合，然后再重新创建整个集合。 因此Bag是非常低效的。</p><p>请注意：对于一对多关联来说，“主键”很可能并不是数据库表的物理主键。 但就算在此情况下，上面的分类仍然是有用的。（它仍然反映了Hibernate在集合的各数据行中是如何进行“定位”的。）</p></div><div lang="zh-cn"><div><h3><a name="performance-collections-mostefficientupdate"></a>20.5.2.  Lists, maps 和sets用于更新效率最高</h3></div><p>根据我们上面的讨论，显然有序集合类型和大多数set都可以在增加、删除、修改元素中拥有最好的性能。</p><p>可论证的是对于多对多关联、值数据集合而言，有序集合类比集合(set)有一个好处。因为<tt>Set</tt>的内在结构， 如果“改变”了一个元素，Hibernate并不会<tt>更新（UPDATE）</tt>这一行。 对于<tt>Set</tt>来说，只有在<tt>插入（INSERT）</tt>和<tt>删除（DELETE）</tt> 操作时“改变”才有效。再次强调：这段讨论对“一对多关联”并不适用。</p><p>注意到数组无法延迟载入，我们可以得出结论，list, map和idbags是最高效的（非反向）集合类型，set则紧随其后。 在Hibernate中，set应该时最通用的集合类型，这时因为“set”的语义在关系模型中是最自然的。</p><p>但是，在设计良好的Hibernate领域模型中，我们通常可以看到更多的集合事实上是带有<tt>inverse=&quot;true&quot;</tt> 的一对多的关联。对于这些关联，更新操作将会在多对一的这一端进行处理。因此对于此类情况，无需考虑其集合的更新性能。</p></div><div lang="zh-cn"><div><h3><a name="performance-collections-mostefficentinverse"></a>20.5.3.  Bag和list是反向集合类中效率最高的</h3></div><p>在把bag扔进水沟之前，你必须了解，在一种情况下，bag的性能(包括list)要比set高得多： 对于指明了<tt>inverse=&quot;true&quot;</tt>的集合类（比如说，标准的双向的一对多关联）， 我们可以在未初始化(fetch)包元素的情况下直接向bag或list添加新元素！ 这是因为<tt>Collection.add()</tt>)或者<tt>Collection.addAll()</tt> 方法 对bag或者List总是返回true（这点与与Set不同）。因此对于下面的相同代码来说，速度会快得多。</p><pre>
Parent p = (Parent) sess.load(Parent.class, id);
    Child c = new Child();
    c.setParent(p);
    p.getChildren().add(c);  //no need to fetch the collection!
    sess.flush();
</pre></div><div lang="zh-cn"><div><h3><a name="performance-collections-oneshotdelete"></a>20.5.4.  一次性删除（One shot delete）</h3></div><p>偶尔的，逐个删除集合类中的元素是相当低效的。Hibernate并没那么笨， 如果你想要把整个集合都删除（比如说调用list.clear()），Hibernate只需要一个DELETE就搞定了。</p><p>假设我们在一个长度为20的集合类中新增加了一个元素，然后再删除两个。 Hibernate会安排一条<tt>INSERT</tt>语句和两条<tt>DELETE</tt>语句（除非集合类是一个bag)。 这当然是显而易见的。</p><p>但是，假设我们删除了18个数据，只剩下2个，然后新增3个。则有两种处理方式：</p><div><ul type="disc"><li><p>逐一的删除这18个数据，再新增三个；</p></li><li><p>删除整个集合类（只用一句DELETE语句），然后增加5个数据。</p></li></ul></div><p>Hibernate还没那么聪明，知道第二种选择可能会比较快。 （也许让Hibernate不这么聪明也是好事，否则可能会引发意外的“数据库触发器”之类的问题。）</p><p>幸运的是，你可以强制使用第二种策略。你需要取消原来的整个集合类（解除其引用）， 然后再返回一个新的实例化的集合类，只包含需要的元素。有些时候这是非常有用的。</p><p>显然，一次性删除并不适用于被映射为<tt>inverse=&quot;true&quot;</tt>的集合。</p></div></div><div lang="zh-cn"><div><h2 style="clear: both"><a name="performance-monitoring"></a>20.6.  监测性能（Monitoring performance）</h2></div><p>没有监测和性能参数而进行优化是毫无意义的。Hibernate为其内部操作提供了一系列的示意图，因此可以从 每个<tt>SessionFactory</tt>抓取其统计数据。</p><div lang="zh-cn"><div><h3><a name="performance-monitoring-sf"></a>20.6.1.  监测SessionFactory</h3></div><p>你可以有两种方式访问<tt>SessionFactory</tt>的数据记录，第一种就是自己直接调用 <tt>sessionFactory.getStatistics()</tt>方法读取、显示<tt>统计</tt>数据。</p><p>此外，如果你打开<tt>StatisticsService</tt> MBean选项，那么Hibernate则可以使用JMX技术 发布其数据记录。你可以让应用中所有的<tt>SessionFactory</tt>同时共享一个MBean，也可以每个 SessionFactory分配一个MBean。下面的代码即是其演示代码：</p><pre>
// MBean service registration for a specific SessionFactory
Hashtable tb = new Hashtable();
tb.put(&quot;type&quot;, &quot;statistics&quot;);
tb.put(&quot;sessionFactory&quot;, &quot;myFinancialApp&quot;);
ObjectName on = new ObjectName(&quot;hibernate&quot;, tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory
server.registerMBean(stats, on); // Register the Mbean on the server
</pre><pre>
// MBean service registration for all SessionFactory's
Hashtable tb = new Hashtable();
tb.put(&quot;type&quot;, &quot;statistics&quot;);
tb.put(&quot;sessionFactory&quot;, &quot;all&quot;);
ObjectName on = new ObjectName(&quot;hibernate&quot;, tb); // MBean object name

StatisticsService stats = new StatisticsService(); // MBean implementation
server.registerMBean(stats, on); // Register the MBean on the server
</pre><p>TODO：仍需要说明的是：在第一个例子中，我们直接得到和使用MBean；而在第二个例子中，在使用MBean之前 我们则需要给出SessionFactory的JNDI名，使用<tt>hibernateStatsBean.setSessionFactoryJNDIName(&quot;my/JNDI/Name&quot;)</tt> 得到SessionFactory，然后将MBean保存于其中。</p><p>你可以通过以下方法打开或关闭<tt>SessionFactory</tt>的监测功能：</p><div><ul type="disc"><li><p>在配置期间，将<tt>hibernate.generate_statistics</tt>设置为<tt>true</tt>或<tt>false</tt>；</p></li></ul></div><div><ul type="disc"><li><p>在运行期间，则可以可以通过<tt>sf.getStatistics().setStatisticsEnabled(true)</tt> 或<tt>hibernateStatsBean.setStatisticsEnabled(true)</tt></p></li></ul></div><p>你也可以在程序中调用<tt>clear()</tt>方法重置统计数据，调用<tt>logSummary()</tt> 在日志中记录（info级别）其总结。</p></div><div lang="zh-cn"><div><h3><a name="performance-monitoring-metrics"></a>20.6.2.  数据记录（Metrics）</h3></div><p>Hibernate提供了一系列数据记录，其记录的内容包括从最基本的信息到与具体场景的特殊信息。所有的测量值都可以由 <tt>Statistics</tt>接口进行访问，主要分为三类：</p><div><ul type="disc"><li><p>使用<tt>Session</tt>的普通数据记录，例如打开的Session的个数、取得的JDBC的连接数等；</p></li><li><p>实体、集合、查询、缓存等内容的统一数据记录</p></li><li><p>和具体实体、集合、查询、缓存相关的详细数据记录</p></li></ul></div><p>例如：你可以检查缓存的命中成功次数，缓存的命中失败次数，实体、集合和查询的使用概率，查询的平均时间等。请注意 Java中时间的近似精度是毫秒。Hibernate的数据精度和具体的JVM有关，在有些平台上其精度甚至只能精确到10秒。</p><p>你可以直接使用getter方法得到全局数据记录（例如，和具体的实体、集合、缓存区无关的数据），你也可以在具体查询中通过标记实体名、 或HQL、SQL语句得到某实体的数据记录。请参考<tt>Statistics</tt>、<tt>EntityStatistics</tt>、 <tt>CollectionStatistics</tt>、<tt>SecondLevelCacheStatistics</tt>、 和<tt>QueryStatistics</tt>的API文档以抓取更多信息。下面的代码则是个简单的例子：</p><pre>
Statistics stats = HibernateUtil.sessionFactory.getStatistics();

double queryCacheHitCount  = stats.getQueryCacheHitCount();
double queryCacheMissCount = stats.getQueryCacheMissCount();
double queryCacheHitRatio =
  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);

log.info(&quot;Query Hit ratio:&quot; + queryCacheHitRatio);

EntityStatistics entityStats =
  stats.getEntityStatistics( Cat.class.getName() );
long changes =
        entityStats.getInsertCount()
        + entityStats.getUpdateCount()
        + entityStats.getDeleteCount();
log.info(Cat.class.getName() + &quot; changed &quot; + changes + &quot;times&quot;  );
</pre><p>如果你想得到所有实体、集合、查询和缓存区的数据，你可以通过以下方法获得实体、集合、查询和缓存区列表： <tt>getQueries()</tt>、<tt>getEntityNames()</tt>、 <tt>getCollectionRoleNames()</tt>和 <tt>getSecondLevelCacheRegionNames()</tt>。</p></div></div></div>
</div></body></html> 