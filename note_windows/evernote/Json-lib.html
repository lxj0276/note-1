<html>
<head>
  <title>Json-lib</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272236; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1440"/>
<h1>Json-lib</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2014/7/20 20:10</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2014/8/21 9:32</i></td></tr>
<tr><td><b>标签：</b></td><td><i>JOSON-解析, JSON-lib, JSON转换</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://json-lib.sourceforge.net/"><i>http://json-lib.sourceforge.net/</i></a></td></tr>
</table>
</div>
<br/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><span style="font-size: 32px;"><b>一、JSON-lib 是一个java类库</b></span><div><b><span style="font-size: 19px;"><a href="http://json-lib.sourceforge.net/">http://json-lib.sourceforge.net/</a><br/></span></b><span style="font-size: 24px;">转换 javabeans, maps, collections, java arrays 和 XML 成为json 格式数据</span><br style="font-size: 24px;"/><span style="font-size: 24px;">转换json格式数据 成为 javabeans 对象</span></div><div><p style="font-size: 24px;"><b>The following tables sumarizes the types conversion between java and javascript:</b><br/></p><table><thead style="font-size: 24px;"><tr><th>JSON</th><th></th><th>Java</th></tr></thead><tbody><tr style="font-size: 24px;"><td>string</td><td>&lt;=&gt;</td><td>java.lang.String, java.lang.Character, char</td></tr><tr style="font-size: 24px;"><td>number</td><td>&lt;=&gt;</td><td>java.lang.Number, byte, short, int, long, float, double</td></tr><tr style="font-size: 24px;"><td>true|false</td><td>&lt;=&gt;</td><td>java.lang.Boolean, boolean</td></tr><tr style="font-size: 24px;"><td>null</td><td>&lt;=&gt;</td><td>null</td></tr><tr style="font-size: 24px;"><td>function</td><td>&lt;=&gt;</td><td>net.sf.json.JSONFunction</td></tr><tr style="font-size: 24px;"><td>array</td><td>&lt;=&gt;</td><td>net.sf.json.JSONArray (object, string, number, boolean, function)</td></tr><tr><td style="font-size: 24px;">object</td><td style="font-size: 24px;">&lt;=&gt;</td><td style="font-size: 24px;">net.sf.json.JSONObject</td></tr></tbody></table><div><span style="font-size: 24px;">二、</span></div></div><div>将Array解析成json串。使用JSONArray可以解析Array类型：</div><div><img src="Json-lib_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><img src="Json-lib_files/Image [1].png" type="image/png" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div><br/></div><div style="font-size: 32px;"><b>二、</b></div><div><h2>How to use json-lib</h2><a href="http://json-lib.sourceforge.net/usage.html#serializer">Using the JSONSerializer</a><br/><a href="http://json-lib.sourceforge.net/usage.html#arrays">Working with arrays and collections</a><br/><a href="http://json-lib.sourceforge.net/usage.html#objects">Working with objects</a><br/><a href="http://json-lib.sourceforge.net/usage.html#xml">Working with XML</a><br/><a name="serializer"></a><div><h3><a name="Using_the_JSONSerializer"></a>Using the JSONSerializer</h3><p>JSONSerializer can transform any java object to JSON notation and back with a simple and clean interface, leveraging all the builders in JSONObject and JSONArray. To transform a java obect into JSON use <code>JSONSerializer.toJSON()</code>. To transform a valid JSON value (by JSON, I mean an Object implementing that interface), use <code>toJava()</code>. The last method is an instance method because the serializer needs special configuration to transform a JSON value to a bean class, array, List or DynaBean.</p></div><a name="arrays"></a><div><h3><a name="Working_with_arrays_and_collections"></a>Working with arrays and collections</h3><p>The simplest way to create a <code>JSONArray</code> from a java array or collection is through the static factory methods from <code>JSONArray</code>. <code>JSONArray.fromObject()</code> will inspect its parameter and call the correct factory or constructor.</p><p>Examples:</p><div><ol start="1"><li>boolean[] boolArray = new boolean[]{true,false,true};  </li><li>JSONArray jsonArray = JSONArray.fromObject( boolArray );  </li><li>System.out.println( jsonArray );  </li><li>// prints [true,false,true]  </li></ol></div><div><ol start="1"><li>List list = new ArrayList();  </li><li>list.add( &quot;first&quot; );  </li><li>list.add( &quot;second&quot; );  </li><li>JSONArray jsonArray = JSONArray.fromObject( list );  </li><li>System.out.println( jsonArray );  </li><li>// prints [&quot;first&quot;,&quot;second&quot;]  </li></ol></div><div><ol start="1"><li>JSONArray jsonArray = JSONArray.fromObject( &quot;['json','is','easy']&quot; );  </li><li>System.out.println( jsonArray );  </li><li>// prints [&quot;json&quot;,&quot;is&quot;,&quot;easy&quot;]  </li></ol></div></div><a name="objects"></a><div><h3><a name="Working_with_objects"></a>Working with objects</h3><div><h3><a name="From_Beans__Maps_to_JSON"></a>From Beans &amp; Maps to JSON</h3><p>The simplest way to create a <code>JSONObject</code> from a bean or <code>Map</code> is through the static factory methods from <code>JSONObject</code>. <code>JSONObject.fromObject()</code> will inspect its parameter and call the correct factory or constructor.</p><p>Examples:</p><div><ol start="1"><li>Map map = new HashMap();  </li><li>map.put( &quot;name&quot;, &quot;json&quot; );  </li><li>map.put( &quot;bool&quot;, Boolean.TRUE );  </li><li>map.put( &quot;int&quot;, new Integer(1) );  </li><li>map.put( &quot;arr&quot;, new String[]{&quot;a&quot;,&quot;b&quot;} );  </li><li>map.put( &quot;func&quot;, &quot;function(i){ return this.arr[i]; }&quot; );  </li><li>  </li><li>JSONObject jsonObject = JSONObject.fromObject( map );  </li><li>System.out.println( jsonObject );  </li><li>// prints [&quot;name&quot;:&quot;json&quot;,&quot;bool&quot;:true,&quot;int&quot;:1,&quot;arr&quot;:[&quot;a&quot;,&quot;b&quot;],&quot;func&quot;:function(i){ return this.arr[i]; }]  </li></ol></div><div><ol start="1"><li>class MyBean{  </li><li>   private String name = &quot;json&quot;;  </li><li>   private int pojoId = 1;  </li><li>   private char[] options = new char[]{'a','f'};  </li><li>   private String func1 = &quot;function(i){ return this.options[i]; }&quot;;  </li><li>   private JSONFunction func2 = new JSONFunction(new String[]{&quot;i&quot;},&quot;return this.options[i];&quot;);  </li><li>  </li><li>   // getters &amp; setters  </li><li>   ...  </li><li>}  </li><li>  </li><li>JSONObject jsonObject = JSONObject.fromObject( new MyBean() );  </li><li>System.out.println( jsonObject );  </li><li>/* prints </li><li>  {&quot;name&quot;:&quot;json&quot;,&quot;pojoId&quot;:1,&quot;options&quot;:[&quot;a&quot;,&quot;f&quot;], </li><li>  &quot;func1&quot;:function(i){ return this.options[i];}, </li><li>  &quot;func2&quot;:function(i){ return this.options[i];}} </li><li>*/  </li></ol></div><center><table><tbody><tr><td><img src="Json-lib_files/Image.gif" type="image/gif" style="cursor: default;cursor: default;cursor: default;"/></td><td><strong><font color="#FF0000">CAUTION:</font></strong> when parsing, JSONObject and JSONArray will check for cycles in the hierarchy, throwing an exception if one is found. You can change this behavior by registering a CycleDetectionStrategy.</td><td><img src="Json-lib_files/Image [1].gif" type="image/gif" style="cursor: default;cursor: default;cursor: default;"/></td></tr></tbody></table></center></div><div><h3><a name="From_JSON_to_Beans"></a>From JSON to Beans</h3><p>Json-lib can transform JSONObjects to either a DynaBean or an specific bean class.<br/>
When using DynaBean all arrays are converted to Lists, when using an specific bean class the transformation will use type conversion if necessary on array properties.</p><p>Convert to DynaBean:</p><div><ol start="1"><li>String json = &quot;{name=\&quot;json\&quot;,bool:true,int:1,double:2.2,func:function(a){ return a; },array:[1,2]}&quot;;  </li><li>JSONObject jsonObject = JSONObject.fromObject( json );  </li><li>Object bean = JSONObject.toBean( jsonObject );  </li><li>assertEquals( jsonObject.get( &quot;name&quot; ), PropertyUtils.getProperty( bean, &quot;name&quot; ) );  </li><li>assertEquals( jsonObject.get( &quot;bool&quot; ), PropertyUtils.getProperty( bean, &quot;bool&quot; ) );  </li><li>assertEquals( jsonObject.get( &quot;int&quot; ), PropertyUtils.getProperty( bean, &quot;int&quot; ) );  </li><li>assertEquals( jsonObject.get( &quot;double&quot; ), PropertyUtils.getProperty( bean, &quot;double&quot; ) );  </li><li>assertEquals( jsonObject.get( &quot;func&quot; ), PropertyUtils.getProperty( bean, &quot;func&quot; ) );  </li><li>List expected = JSONArray.toList( jsonObject.getJSONArray( &quot;array&quot; ) );  </li><li>Assertions.assertListEquals( expected, (List) PropertyUtils.getProperty( bean, &quot;array&quot; ) );  </li></ol></div><p>Convert to Bean:</p><div><ol start="1"><li>String json = &quot;{bool:true,integer:1,string:\&quot;json\&quot;}&quot;;  </li><li>JSONObject jsonObject = JSONObject.fromObject( json );  </li><li>BeanA bean = (BeanA) JSONObject.toBean( jsonObject, BeanA.class );  </li><li>assertEquals( jsonObject.get( &quot;bool&quot; ), Boolean.valueOf( bean.isBool() ) );  </li><li>assertEquals( jsonObject.get( &quot;integer&quot; ), new Integer( bean.getInteger() ) );  </li><li>assertEquals( jsonObject.get( &quot;string&quot; ), bean.getString() );  </li></ol></div><p>There are two special cases when converting to an specific bean, if the target bean has a Map property and it must contain other beans, <code>JSONObject.toBean()</code> will transform the nested beans into DynaBeans. If you need those nested beans transformed into an specific class, you can either postprocess the Map attribute or provide hints on JSONObject's attributes for conversion. <code>JSONObject.toBean()</code> may be passed a third argument, a Map, that will provide thos hints. Every key must be either the name of a property or a regular expression matching the object's properties, and the value must be a <code>Class</code>.</p><p>The second case is similar and it happens when the target bean has a Collection (List) as a property and it must contain other beans. In this case there is no way to provide hints for class conversion. The only possible solution is to postprocess the collection transforming each DynaBean into an specific bean.</p><p>To ease the postprocessing scenarios, EZMorph provides a Morpher capable of transforming a DynaBean into an specific bean, <a href="http://ezmorph.sourceforge.net/apidocs/net/sf/ezmorph/bean/BeanMorpher.html"><code>BeanMorpher</code></a><br/>
Example:</p><div><ol start="1"><li>class MyBean{  </li><li>   private List data;  </li><li>   // getters &amp; setters  </li><li>}  </li><li>  </li><li>class Person{  </li><li>   private String name;  </li><li>   // getters &amp; setters  </li><li>}  </li><li>  </li><li>...  </li><li>  </li><li>String json = &quot;{'data':[{'name':'Wallace'},{'name':'Grommit'}]}&quot;;  </li><li>Map classMap = new HashMap();  </li><li>classMap.put( &quot;data&quot;, Person.class );  </li><li>MyBean bean = JSONObject.toBean( JSONObject.fromObject(json), MyBean.class, classMap );  </li></ol></div><p>This yields a MyBean instance that has DynaBeans inside the 'data' attribute', so now comes the part of postprocessing, this can be done with an Iterator<br/>
Example:</p><div><ol start="1"><li>Morpher dynaMorpher = new BeanMorpher( Person.class, JSONUtils.getMorpherRegistry() );  </li><li>morpherRegistry.registerMorpher( dynaMorpher );  </li><li>List output = new ArrayList();  </li><li>for( Iterator i = bean.getData().iterator(); i.hasNext(); ){  </li><li>   output.add( morpherRegistry.morph( Person.class, i.next() ) );  </li><li>}  </li><li>bean.setData( output );  </li></ol></div><p>To learn more about Morphers, please visit <a href="http://ezmorph.sourceforge.net/">EZMorph's project site</a>.</p></div></div><a name="xml"></a><div><h3><a name="Working_with_XML"></a>Working with XML</h3><p>Working with XML has become easier since version 1.1. Transforming JSONObjects and JSONArrays from and to XML is done through the XMLSerializer.</p><div><h3><a name="From_JSON_to_XML"></a>From JSON to XML</h3><p>Writing to JSON to XML is as simple as calling <code>XMLSerializer.write()</code>, but there are a lot of options that you may configure to get better control of the XML output. For example you may change the default names for the root element ('o' if object, 'a' if array), the default name for object (an object inside an array is &quot;anonymous&quot;), the default name for array (for the same reason as object), the default name for element (array items have no name). If you'd like to output namescape information but your JSON does not includes it, no problem, you have 8 methods that will let you register and manage namespaces; namespaces defined this way have precedence on any namespace declaration that may be inside the JSON. By default XMLSerializer will append special attributes to each xml element for easing the transformation back to JSON but you may configure it to skip appending those attributes. Any property on a JSONObject that begins with '@' will be treated as an attribute, any property named '#text' will be treated as a Text node.</p><p>Please review the javadoc for XMLSerializer to know more about the configurable options.</p><table><tbody><tr><th>Code</th><th>XML output</th></tr><tr><td><div><ol start="1"><li>JSONObject json = new JSONObject( true );  </li><li>String xml = XMLSerializer.write( json );  </li></ol></div></td><td><div><ol start="1"><li>&lt;o class=&quot;object&quot; null=&quot;true&quot;&gt;  </li><li>      </li></ol></div></td></tr><tr><td><div><ol start="1"><li>JSONObject json = JSONObject.fromObject(&quot;{\&quot;name\&quot;:\&quot;json\&quot;,\&quot;bool\&quot;:true,\&quot;int\&quot;:1}&quot;);  </li><li>String xml = XMLSerializer.write( json );  </li></ol></div></td><td><div><ol start="1"><li>&lt;o class=&quot;object&quot;&gt;  </li><li>   &lt;name type=&quot;string&quot;&gt;json&lt;/name&gt;  </li><li>   &lt;bool type=&quot;boolean&quot;&gt;true&lt;/bool&gt;  </li><li>   &lt;int type=&quot;number&quot;&gt;1&lt;/int&gt;  </li><li>&lt;/o&gt;  </li></ol></div></td></tr><tr><td><div><ol start="1"><li>JSONArray json = JSONArray.fromObject(&quot;[1,2,3]&quot;);  </li><li>String xml = XMLSerializer.write( json );  </li></ol></div></td><td><div><ol start="1"><li>&lt;a class=&quot;array&quot;&lt;  </li><li>   &lt;e type=&quot;number&quot;&gt;1&lt;/e&gt;  </li><li>   &lt;e type=&quot;number&quot;&gt;2&lt;/e&gt;  </li><li>   &lt;e type=&quot;number&quot;&gt;3&lt;/e&gt;  </li><li>&lt;/a&gt;  </li></ol></div></td></tr></tbody></table></div><div><h3><a name="From_XML_to_JSON"></a>From XML to JSON</h3><p>XMLSerializer treats each element as a <code>string</code> unless a type parameter is specified.<br/>
JSONFunction needs an additional parameter that specifies that function's params.<br/>
All xml attributes will have the prefix '@' and text nodes will have the property name '#text'. XMLSerializer supports the rules outlined at <a href="http://www.xml.com/pub/a/2006/05/31/converting-between-xml-and-json.html">Converting Between XML and JSON</a></p><table><tbody><tr><th>XML input</th><th>Code</th></tr><tr><td><div><ol start="1"><li>&lt;a class=&quot;array&quot;&gt;  </li><li>  &lt;e type=&quot;function&quot; params=&quot;i,j&quot;&gt;  </li><li>      return matrix[i][j];  </li><li>  &lt;/e&gt;  </li><li>&lt;/a&gt;  </li></ol></div></td><td><div><ol start="1"><li>JSONArray json = (JSONArray) XMLSerializer.read( xml );  </li><li>System.out.println( json );  </li><li>// prints [function(i,j){ return matrix[i][j]; }]  </li></ol></div></td></tr></tbody></table></div></div></div></div>
</div></body></html> 