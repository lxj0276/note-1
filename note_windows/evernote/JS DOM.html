<html>
<head>
  <title>JS DOM</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272236; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="5661"/>
<h1>JS DOM</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2014/8/20 21:06</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2014/8/20 21:22</i></td></tr>
<tr><td><b>标签：</b></td><td><i>DOM, JS</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="about:blank"><i>about:blank</i></a></td></tr>
</table>
</div>
<br/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="background-color: inherit; font-family: 微软雅黑; font-size: 14px;">DOM<br style="background-color: inherit;"/>
   1,DOM概述及分类？<br style="background-color: inherit;"/>
        document object model  文档对象模型<br style="background-color: inherit;"/>
        是W3C织制订的一套用于访问XML和HTML文档的标准.允许脚本动态地访问和更新文档的内容、结构和样式.<br style="background-color: inherit;"/>
     分类<br style="background-color: inherit;"/>
        DOM Core<br style="background-color: inherit;"/>
        XML DOM<br style="background-color: inherit;"/>
        HTML DOM<br style="background-color: inherit;"/>
   2,XML DOM 和 HTML DOM 关系?<br style="background-color: inherit;"/>
        DOM---&gt;XML DOM---&gt;HTML DOM<br style="background-color: inherit;"/>
   3,结点，结点树，结点属性与方法？<br style="background-color: inherit;"/>
     在XML DOM每个元素 都会被解析为一个节点Node，而常用的节点类型又分为<br style="background-color: inherit;"/>
        1). 元素节点:Element<br style="background-color: inherit;"/>
        2). 属性节点:Attr 元素的属性, 可以直接通过属性的方式来操作. <br style="background-color: inherit;"/>
        3). 文本节点:Text 是元素节点的子节点, 其内容为文本.<br style="background-color: inherit;"/>
        4). 文档节点  Document<br style="background-color: inherit;"/>
   4,XML DOM操作综合练习<br style="background-color: inherit;"/>
        1)获取节点<br style="background-color: inherit;"/>
          document对象常用方法<br style="background-color: inherit;"/>
                getElementById():根据 id 属性获取对应的单个节点 <br style="background-color: inherit;"/>
                getElementsByName():标签名获取指定节点名字的数组, 数组对象 length 属性可以获取数组的长度 <br style="background-color: inherit;"/>
                getElementsByTagName():根据节点的 name 属性获取符合条件的节点数组, <br style="background-color: inherit;"/>
                        但 ie 的实现方式和 W3C 标准有差别: <br style="background-color: inherit;"/>
                        在 html 文档中若某节点(li)没有 name 属性,　<br style="background-color: inherit;"/>
                        则 ie 使用 getElementsByName 不能获取到节点数组, 但火狐可以. <br style="background-color: inherit;"/>
         <br style="background-color: inherit;"/>
          DOM 节点常用属性<br style="background-color: inherit;"/>
                nodeName: 代表当前节点的名字. 只读属性<br style="background-color: inherit;"/>
                        如果节点是元素节点，nodeName返回这个元素的名称<br style="background-color: inherit;"/>
                        如果是属性节点，nodeName返回这个属性的名称<br style="background-color: inherit;"/>
                        如果是文本节点，nodeName返回一个内容为#text 的字符串 <br style="background-color: inherit;"/>
                nodeType：返回一个整数, 这个数值代表着给定节点的类型. 只读属性<br style="background-color: inherit;"/>
                        Node.ELEMENT_NODE    ---1    -- 元素节点<br style="background-color: inherit;"/>
                        Node.ATTRIBUTE_NODE  ---2    -- 属性节点<br style="background-color: inherit;"/>
                        Node.TEXT_NODE       ---3    -- 文本节点<br style="background-color: inherit;"/>
                nodeValue：返回给定节点的当前值(字符串). 可读写的属性<br style="background-color: inherit;"/>
                        ①. 元素节点, 返回值是 null.<br style="background-color: inherit;"/>
                        ②. 属性节点: 返回值是这个属性的值<br style="background-color: inherit;"/>
                        ③. 文本节点: 返回值是这个文本节点的内容<br style="background-color: inherit;"/>
          <br style="background-color: inherit;"/>
          DOM节点常见操作<br style="background-color: inherit;"/>
                DOM 获取节点 <br style="background-color: inherit;"/>
                   a,获取属性节点:<br style="background-color: inherit;"/>
                        1). **可以直接通过 cityNode.id 这样的方式来获取和设置属性节点的值<br style="background-color: inherit;"/>
                        2). 通过元素节点的 getAttributeNode 方法来获取属性节点,<br style="background-color: inherit;"/>
                            然后在通过 nodeValue 来读写属性值 <br style="background-color: inherit;"/>
                   b,获取元素节点的子节点(**只有元素节点才有子节点!!):<br style="background-color: inherit;"/>
                        1). childNodes 属性获取全部的子节点, 但该方法不实用. 因为如果要获取指定的节点<br style="background-color: inherit;"/>
                            的指定子节点的集合, 可以直接调用元素节点的 getElementsByTagName() 方法来获取. <br style="background-color: inherit;"/>
                        2). firstChild 属性获取第一个子节点<br style="background-color: inherit;"/>
                        3). lastChild  属性获取最后一个子节点                <br style="background-color: inherit;"/>
        <br style="background-color: inherit;"/>
                   c,获取文本节点:<br style="background-color: inherit;"/>
                        1). 步骤: 元素节点 --&gt; 获取元素节点的子节点<br style="background-color: inherit;"/>
                        2). 若元素节点只有文本节点一个子节点, <br style="background-color: inherit;"/>
                            例如 &lt;li id=&quot;bj&quot; name=&quot;BeiJing&quot;&gt;北京&lt;/li&gt;, &lt;p&gt;你喜欢哪个城市?&lt;/p&gt;, <br style="background-color: inherit;"/>
                            可以先获取到指定的元素节点 eleNode, <br style="background-color: inherit;"/>
                            然后利用 eleNode.firstChild.nodeValue 的方法来读写其文本节点的值<br style="background-color: inherit;"/>
                <br style="background-color: inherit;"/>
                DOM 改变节点 <br style="background-color: inherit;"/>
                    1)创建一个元素节点:<br style="background-color: inherit;"/>
                        createElement(): 按照给定的标签名创建一个新的元素节点. 方法只有一个参数：被创建的元素节点的名字, 是一个字符串.</div><div style="background-color: inherit; font-family: 微软雅黑; font-size: 14px;">                            方法的返回值：是一个指向新建节点的引用指针. 返回值是一个元素节点, 所以它的 nodeType 属性值等于 1.<br style="background-color: inherit;"/>
                            **新元素节点不会自动添加到文档里, 它只是一个存在于 JavaScript 上下文的对象.<br style="background-color: inherit;"/>
                    2)创建一个文本节点:<br style="background-color: inherit;"/>
                        createTextNode(): 创建一个包含着给定文本的新文本节点. 这个方法的返回值是一个指向新建文本节点引用指针. 它是一个文本节点, 所以它的 nodeType 属性等于 3.<br style="background-color: inherit;"/>
                            方法只有一个参数：新建文本节点所包含的文本字符串. 新元素节点不会自动添加到文档里<br style="background-color: inherit;"/>
                    3)为元素节点添加子节点:]appendChild(): 父节点.appendChild(子节点): 给定子节点 newChild 将成为给定元素节点 element 的最后一个子节点.<br style="background-color: inherit;"/>
                            方法的返回值是一个指向新增子节点的引用指针.<br style="background-color: inherit;"/>
                    4)节点的替换:<br style="background-color: inherit;"/>
                        a). replaceChild(): 把一个给定父元素里的一个子节点替换为另外一个子节点<br style="background-color: inherit;"/>
                                var reference = element.replaceChild(newChild,oldChild);<br style="background-color: inherit;"/>
                                返回值是一个指向已被替换的那个子节点的引用指针<br style="background-color: inherit;"/>
                                该节点除了替换功能以外还有移动的功能.  <br style="background-color: inherit;"/>
                                该方法只能完成单向替换, 若需要使用双向替换, 需要自定义函数:<br style="background-color: inherit;"/>
                        b)旧节点.replaceNode(新节点)<br style="background-color: inherit;"/>
                    5)插入节点:<br style="background-color: inherit;"/>
                        1). insertBefore(): 把一个给定节点插入到一个给定元素节点的给定子节点的前面<br style="background-color: inherit;"/>
                                  var reference =  element.insertBefore(newNode,targetNode);<br style="background-color: inherit;"/>
                                节点 newNode 将被插入到元素节点 element 中并出现在节点 targetNode 的前面. <br style="background-color: inherit;"/>
                                节点 targetNode 必须是 element 元素的一个子节点。<br style="background-color: inherit;"/>
                    6)删除节点:<br style="background-color: inherit;"/>
                        1). removeChild(): 从一个给定元素里删除一个子节点<br style="background-color: inherit;"/>
                                父节点.removeChild(子节点)<br style="background-color: inherit;"/>
                                   var reference = element.removeChild(node);<br style="background-color: inherit;"/>
                                返回值是一个指向已被删除的子节点的引用指针. <br style="background-color: inherit;"/>
                                某个节点被 removeChild() 方法删除时, 这个节点所包含的所有子节点将同时被删除. <br style="background-color: inherit;"/>
                                如果想删除某个节点, 但不知道它的父节点是哪一个, parentNode 属性可以帮忙。<br style="background-color: inherit;"/>
                    7)innerHTML属性:<br style="background-color: inherit;"/>
                        1). 浏览器几乎都支持该属性, 但不是 DOM 标准的组成部分. innerHTML 属性可以用来读, <br style="background-color: inherit;"/>
                                写某给定元素里的 HTML 内容        <br style="background-color: inherit;"/>
        <br style="background-color: inherit;"/>
        option:代表下拉列表的下拉选项<br style="background-color: inherit;"/>
        new option(&quot;文本&quot;,&quot;value属性值&quot;);<br style="background-color: inherit;"/><br style="background-color: inherit;"/><br style="background-color: inherit;"/>
(扩展)javascript中模拟类的定义<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
1,定义类(一个函数就是一个类)<br style="background-color: inherit;"/>
   私有/公有 属性<br style="background-color: inherit;"/>
        a,私有属性:用var声明,不能通过对象名去访问<br style="background-color: inherit;"/>
        b,公有属性:用this声明<br style="background-color: inherit;"/>
   私有方法/公有方法<br style="background-color: inherit;"/>
        a,私有方法用var声明<br style="background-color: inherit;"/>
        b,公有的用this声明  ，可以同名<br style="background-color: inherit;"/>
        私有方法只能调用私有属性,但是公有方法可以调用公有的和私有的属性<br style="background-color: inherit;"/>
        function Person(){<br style="background-color: inherit;"/>
                var name=&quot;张三丰&quot;;//私有的属性<br style="background-color: inherit;"/>
                this.age = 30;//公有的属性<br style="background-color: inherit;"/>
                <br style="background-color: inherit;"/>
                var showInfo1 = function(){//私有方法,只能调用私有属性<br style="background-color: inherit;"/>
                        alert(name);<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
                this.showInfo = function(){//公有方法,属性都能用(公有的，私有的)<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
                        showInfo1();//调的私有方法<br style="background-color: inherit;"/>
                        alert(name+&quot;,&quot;+this.age);<br style="background-color: inherit;"/>
                        this.showInfo();//会产生递归,有雷!!!!<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
                //产生对象<br style="background-color: inherit;"/>
        var p = new Person();<br style="background-color: inherit;"/>
        alert(p.name);//undefined 因为是私有的<br style="background-color: inherit;"/>
        alert(p.age);//30<br style="background-color: inherit;"/>
        p.showInfo1();//私有的,不能调用<br style="background-color: inherit;"/>
        p.showInfo();<br style="background-color: inherit;"/>
2,静态属性与静态方法<br style="background-color: inherit;"/>
     定义格式:        <br style="background-color: inherit;"/>
        在类的外面用类名.属性名或类名.方法名<br style="background-color: inherit;"/>
        访问也是类名.属性名或方法名<br style="background-color: inherit;"/>
        不能用对象调用<br style="background-color: inherit;"/>
        function Person(){//定义类<br style="background-color: inherit;"/>
                this.name=&quot;刘小晨&quot;;<br style="background-color: inherit;"/>
                this.age=18;<br style="background-color: inherit;"/>
            }<br style="background-color: inherit;"/>
        Person.sex=&quot;女&quot;;//静态属性<br style="background-color: inherit;"/>
        //静态方法<br style="background-color: inherit;"/>
        Person.showInfo = function (){<br style="background-color: inherit;"/>
                alert(this.name+&quot;,&quot;+this.age+Person.sex);<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
        //静态的调用形式：类名.属性名或方法名<br style="background-color: inherit;"/>
        alert(Person.sex);//调用静态属性,输出结果:女<br style="background-color: inherit;"/>
        Person.showInfo();//调用静态方法,输出结果:undefined,undefined,女<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
        var p = new Person();<br style="background-color: inherit;"/>
        alert(p.name+&quot;,&quot;+p.age+&quot;,&quot;+Person.sex);//刘小晨,18,女<br style="background-color: inherit;"/>
        p.showInfo();//不以调,因为静态不能使用对象调用,直接类名调用<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
3,构造方法<br style="background-color: inherit;"/>
        JS自定义类在创建的时候如果传入了参数,就是有参构造,如果没传参数,就是无参构造<br style="background-color: inherit;"/>
        //有参构造<br style="background-color: inherit;"/>
         function Person(name,age){<br style="background-color: inherit;"/>
                this.name = name;<br style="background-color: inherit;"/>
                this. age  = age;<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
        //无参构造<br style="background-color: inherit;"/>
        function Person(){<br style="background-color: inherit;"/>
                this.name=&quot;王康&quot;;<br style="background-color: inherit;"/>
                this.age = 20;<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
        构造函数在调用的时候,如果存在同名的,调用的是离调用者最近的那个;<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
4,原型(prototype)方式声明属性与方法(一般在做插件或框架时用,)<br style="background-color: inherit;"/>
        格式:<br style="background-color: inherit;"/>
        对象名.prototype.函数名=function(){<br style="background-color: inherit;"/>
                代码...<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
        1.直接原型声明属性和方法<br style="background-color: inherit;"/>
        2.为引用类型赋值出问题？<br style="background-color: inherit;"/>
                解决方案:可以把引用类型放在类的定义中,用prototype专门去扩展方法<br style="background-color: inherit;"/>
        3.有参构造与原型结合一起用!<br style="background-color: inherit;"/>
   怎样自定义数组求最大值的函数库?使以后可以直接数组名.getMax()得到最大值<br style="background-color: inherit;"/>
        <br style="background-color: inherit;"/>
        Array.prototype.getMax=function(){<br style="background-color: inherit;"/>
                var max = this[0];<br style="background-color: inherit;"/>
                for(var i=1;i&lt;this.length;i++){<br style="background-color: inherit;"/>
                        max =max&lt;this[i]?this[i]:max;<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
                return max;<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
        var score = [30,50,67,10,80,45];<br style="background-color: inherit;"/>
        var maxVal = score.getMax();//调用自定义求最值方法,得到最大值<br style="background-color: inherit;"/>
        alert(maxVal);<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
        function Person(){<br style="background-color: inherit;"/>
            this.name=&quot;苏周周&quot;;<br style="background-color: inherit;"/>
                this.age = 18;<br style="background-color: inherit;"/>
                this.hobby =  [&quot;爱avi&quot;,&quot;拍avi&quot;,&quot;实战avi&quot;];//放在这里解决了引用类型赋值的问题<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
        prototype找原型<br style="background-color: inherit;"/>
        Person.prototype.sex = &quot;男人&quot;;//扩展的属性<br style="background-color: inherit;"/>
        Person.prototype.hobby = [&quot;爱avi&quot;,&quot;拍avi&quot;,&quot;实战avi&quot;];//放在这里会出问题,被操作的数据在其它地方调用时会改变<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
        var p = new Person();<br style="background-color: inherit;"/>
        p.hobby.push(&quot;打鸟&quot;);<br style="background-color: inherit;"/>
        alert(p.hobby);<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
        var p2 = new Person();<br style="background-color: inherit;"/>
        alert(p2.hobby);<br style="background-color: inherit;"/>
5,直接用Object对象或函数对象加属性与方法<br style="background-color: inherit;"/>
        a.直接用Object对象，再去定义属性和方法<br style="background-color: inherit;"/>
        b.先定义函数对象，再去定义属性和方法<br style="background-color: inherit;"/>
        c.json对象方式<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
        var obj = new Object();//直接使用对象加属性<br style="background-color: inherit;"/>
        obj.name=&quot;齐航&quot;;<br style="background-color: inherit;"/>
        obj.age = 18;<br style="background-color: inherit;"/>
        obj.北京市=[&quot;海淀&quot;,&quot;昌平&quot;,&quot;东城&quot;];<br style="background-color: inherit;"/>
        obj[&quot;朝阳市&quot;] = [&quot;朝北&quot;,&quot;朝东&quot;,&quot;朝西&quot;];<br style="background-color: inherit;"/>
        obj.showInfo = function (){<br style="background-color: inherit;"/>
                alert(obj.name+&quot;,&quot;+obj.age+&quot;,&quot;+obj.朝阳市.join(&quot;~&quot;));<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
        obj.showInfo();<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
        function Person(){//定义类<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
        var p = new Person();//创建类的对象<br style="background-color: inherit;"/>
        p.name=&quot;齐航&quot;;//添加属性<br style="background-color: inherit;"/>
        p.age = 18;<br style="background-color: inherit;"/>
        p.北京市=[&quot;海淀&quot;,&quot;昌平&quot;,&quot;东城&quot;];<br style="background-color: inherit;"/>
        p[&quot;朝阳市&quot;] = [&quot;朝北&quot;,&quot;朝东&quot;,&quot;朝西&quot;];<br style="background-color: inherit;"/>
        p.showInfo = function (){<br style="background-color: inherit;"/>
                alert(p.name+&quot;,&quot;+p.age+&quot;,&quot;+p.朝阳市.join(&quot;~&quot;));<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
        p.showInfo();<br style="background-color: inherit;"/>
---------------经典的使用的格式-------------------------------<br style="background-color: inherit;"/>
        function Person(name,age){<br style="background-color: inherit;"/>
                this.name = name;<br style="background-color: inherit;"/>
                this.age = age;<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
                this.showInfo= function (){<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
        }<br style="background-color: inherit;"/>
--------------------------------------------------------------<br style="background-color: inherit;"/>
6,JSON数据<br style="background-color: inherit;"/>
        json主要作用是一种当前最流行的数据交换格式     <br style="background-color: inherit;"/>
        优点:在于解析方便,而且传输数据量少<br style="background-color: inherit;"/>
        a.json对象&lt;-----数据库表,使用{}括起来<br style="background-color: inherit;"/>
            var p = {name:&quot;张杰&quot;, age:29,sex:&quot;男&quot;,showInfo:function(){alert(this.name+&quot;,&quot;+this.age);}};<br style="background-color: inherit;"/>
        b,json数组,使用[]定义,里面可以有{}<br style="background-color: inherit;"/>
            var list = [{name:&quot;张杰&quot;,age:29,sex:&quot;男&quot;},{name:&quot;张杰2&quot;,age:22,sex:&quot;男2&quot;},{name:&quot;张杰3&quot;,age:23,sex:&quot;男3&quot;}];<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
7,继承: 要使用原型来进行模拟<br style="background-color: inherit;"/>
        function Person(){//父类<br style="background-color: inherit;"/>
                this.name=&quot;郑志强&quot;;<br style="background-color: inherit;"/>
                this.age = 20;<br style="background-color: inherit;"/>
                 this.showInfo = function(){<br style="background-color: inherit;"/>
                        alert(&quot;hello&quot;);<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/>
         function Student(){//子类<br style="background-color: inherit;"/>
                this.score = 100;<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/>
         var p = new Person();//父类对象<br style="background-color: inherit;"/>
         //继承<br style="background-color: inherit;"/>
         Student.prototype = p;//有这一句后就实现了继承<br style="background-color: inherit;"/>
8,重写(通过protopype实现重写)<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
         Student.prototype.showInfo = function(){//这一句实现了方法重写<br style="background-color: inherit;"/>
                alert(this.name+&quot;,&quot;+this.age+&quot;,&quot;+this.score);<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/>
         var stu = new Student();<br style="background-color: inherit;"/>
         stu.showInfo();<br style="background-color: inherit;"/>
         p.showInfo();//也是重写之后的方法<br style="background-color: inherit;"/>
9,函数重载<br style="background-color: inherit;"/>
         function add2(x,y){//需要重载的方法<br style="background-color: inherit;"/>
                return x+y;<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
         function add3(x,y,z){//需要重载的方法<br style="background-color: inherit;"/>
                return x+y+z;<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
         function add4(x,y,z,q){//需要重载的方法<br style="background-color: inherit;"/>
                return x+y+z+q;<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
         function add(){//重新定义一个方法,通过arguments模拟重载,而arguments本身是一个数组<br style="background-color: inherit;"/>
                if(arguments.length==2){<br style="background-color: inherit;"/>
                        return add2(arguments[0],arguments[1]);<br style="background-color: inherit;"/>
                } else if(arguments.length==3){<br style="background-color: inherit;"/>
                        return add3(arguments[0],arguments[1],arguments[2]);<br style="background-color: inherit;"/>
                }else if(arguments.length==4){<br style="background-color: inherit;"/>
                        return add4(arguments[0],arguments[1],arguments[2],arguments[3]);<br style="background-color: inherit;"/>
                }else{<br style="background-color: inherit;"/>
                        return &quot;不支持!!&quot;;<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/>
          var result = add(10);<br style="background-color: inherit;"/>
          var result = add(10,20,30,40,50);<br style="background-color: inherit;"/>
         var result = add(&quot;dfds10&quot;,&quot;fsdfdsf20&quot;);<br style="background-color: inherit;"/>
         var result = add(10,20,30);<br style="background-color: inherit;"/>
         var result = add(10,20,30,40);<br style="background-color: inherit;"/>
         alert(result);<br style="background-color: inherit;"/>
10,with语句与for..in语句<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
         function Person(){//定义一个类<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
                this.name = &quot;刘岳林&quot;;<br style="background-color: inherit;"/>
                this.age = &quot;20&quot;;<br style="background-color: inherit;"/>
                this.showInfo = function(){<br style="background-color: inherit;"/>
                        alert(this.name+&quot;,&quot;+this.age);<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
         }<br style="background-color: inherit;"/>
        with语句，用于指定要访问的对象是谁<br style="background-color: inherit;"/>
         var p = new Person();<br style="background-color: inherit;"/>
         with(p){//这里p代表的Person对象,而且被它控制的语句里面对象名可以不写,因为被代表了<br style="background-color: inherit;"/>
                alert(name);<br style="background-color: inherit;"/>
                alert(age);<br style="background-color: inherit;"/>
                showInfo();<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
        for..in用于访问对象的属性和方法<br style="background-color: inherit;"/><br style="background-color: inherit;"/>
          var p1 = new Person();<br style="background-color: inherit;"/>
          for(var i in p1){<br style="background-color: inherit;"/>
                if(p[i] instanceof Function){<br style="background-color: inherit;"/>
                        p[i]();//调用方法<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
                else{<br style="background-color: inherit;"/>
                        alert(p[i]);<br style="background-color: inherit;"/>
                }<br style="background-color: inherit;"/>
          }</div></div>
</div></body></html> 