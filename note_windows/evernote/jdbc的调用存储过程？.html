<html>
<head>
  <title>jdbc的调用存储过程？</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272236; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="1598"/>
<h1>jdbc的调用存储过程？</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2014/7/21 19:51</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2014/7/30 4:47</i></td></tr>
<tr><td><b>来源：</b></td><td><a href="http://sjsky.iteye.com/blog/1246657"><i>http://sjsky.iteye.com/blog/1246657</i></a></td></tr>
</table>
</div>
<br/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div style="font-size: 24px;"> 关键字：call 语法格式{call 存储过程名(参数列表)} </div><div><p>本文主要是总结 如何实现 JDBC调用Oracle的存储过程，从以下情况分别介绍：</p><ul><li><span style="color: #0000ff;">[1]、只有输入IN参数，没有输出OUT参数</span></li><li><span style="color: #0000ff;">[2]、既有输入IN参数，也有输出OUT参数，输出是简单值（非列表）</span></li><li><span style="color: #0000ff;">[3]、既有输入IN参数，也有输出OUT参数，输出是列表</span></li><li><span style="color: #0000ff;">[4]、输入输出参数是同一个（IN OUT）</span></li></ul><p><strong>【准备工作】</strong></p><p>  创建一个测试表<span style="color: #ff0000;">TMP_MICHAEL</span> ，并插入数据，SQL如下：</p><div><div>Sql代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image.png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>create table TMP_MICHAEL  </li><li>(  </li><li>  USER_ID    VARCHAR2(20),  </li><li>  USER_NAME  VARCHAR2(10),  </li><li>  SALARY     NUMBER(8,2),  </li><li>  OTHER_INFO VARCHAR2(100)  </li><li>)  </li><li>  </li><li>insert into TMP_MICHAEL (USER_ID, USER_NAME, SALARY, OTHER_INFO)  </li><li>values ('michael', 'Michael', 5000, 'http://sjsky.iteye.com');  </li><li>insert into TMP_MICHAEL (USER_ID, USER_NAME, SALARY, OTHER_INFO)  </li><li>values ('zhangsan', '张三', 10000, null);  </li><li>insert into TMP_MICHAEL (USER_ID, USER_NAME, SALARY, OTHER_INFO)  </li><li>values ('aoi_sola', '苍井空', 99999.99, 'twitter account');  </li><li>insert into TMP_MICHAEL (USER_ID, USER_NAME, SALARY, OTHER_INFO)  </li><li>values ('李四', '李四', 2500, null);  </li></ol></div><p>  Oracle jdbc 常量：</p><div><div>Java代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [1].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>private final static String DB_DRIVER = &quot;oracle.jdbc.driver.OracleDriver&quot;;  </li><li>private final static String DB_CONNECTION = &quot;jdbc:oracle:thin:@127.0.0.1:1521:Ora11g&quot;;  </li><li>private final static String DB_NAME = &quot;mytest&quot;;  </li><li>private final static String DB_PWd = &quot;111111&quot;;  </li></ol></div><p> <span style="color: rgb(0, 0, 255);">[一]、只有输入IN参数，没有输出OUT参数</span></p><p> </p><p> </p><p><span style="color: #ff0000;">存储过程 TEST_MICHAEL_NOOUT</span> 的相关SQL：</p><div>Sql代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [2].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/> </a></div><div><br/></div><div> /**<br/>
     * 测试调用存储过程：返回值是简单值非列表<br/>
     * @blog http://sjsky.iteye.com<br/>
     * @author Michael<br/>
     * @throws Exception<br/>
     */<br/>
    public static void testProcOutSimple() throws Exception {<br/>
        System.out.println(&quot;-------  start 测试调用存储过程：返回值是简单值非列表&quot;);<br/>
        Connection conn = null;<br/>
    <span style="font-size: 19px;">   </span> <font color="#41AD1C" style="font-size: 19px;">CallableStatement stmt = null;</font><br/>
        try {<br/>
            Class.forName(DB_DRIVER);<br/>
            conn = DriverManager.getConnection(DB_CONNECTION, DB_NAME, DB_PWd);<br/><br/>
            <span style="font-size: 19px;">stmt = conn.prepareCall(&quot;{</span><font color="#41AD1C" style="font-size: 19px;">call TEST_MICHAEL(?,?,?)</font><span style="font-size: 19px;">}&quot;);</span><br style="font-size: 19px;"/><br style="font-size: 19px;"/><span style="font-size: 19px;">          stmt.setString(1, &quot;&quot;);</span><br style="font-size: 19px;"/><span style="font-size: 19px;">          stmt.setDouble(2, 3000);</span><br/><br/>
            // out 注册的index 和取值时要对应<br/>
            stmt.registerOutParameter(3, Types.INTEGER);<br/>
            stmt.execute();<br/><br/>
            // getXxx(index)中的index 需要和上面registerOutParameter的index对应<br/>
            <span style="font-size: 19px;">int i = stmt.getInt(3);</span><br/>
            System.out.println(&quot;符号条件的查询结果 count := &quot; + i);<br/>
            System.out.println(&quot;-------  Test End.&quot;);<br/>
        } catch (Exception e) {<br/>
            e.printStackTrace(System.out);<br/>
        } finally {<br/>
            if (null != stmt) {<br/>
                stmt.close();<br/>
            }<br/>
            if (null != conn) {<br/>
                conn.close();<br/>
            }<br/>
        }<br/>
    }</div><div> 运行后查询数据库内容,已经成功插入数据，截图如下：</div><p><br/><img src="http://dl.iteye.com/upload/attachment/585548/85dc3a77-b595-316c-850c-56b1d120d70d.png" style="cursor: default;cursor: default;cursor: default;"></img></p><p> </p><p><span style="color: rgb(0, 0, 255);">[二]、既有输入IN参数，也有输出OUT参数，输出是简单值（非列表）</span></p><p> </p><p><span style="color: #ff0000;">存储过程 TEST_MICHAEL</span> 的SQL如下：</p><div><div>Sql代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [3].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>CREATE OR REPLACE PROCEDURE TEST_MICHAEL(P_USERID IN VARCHAR2,  </li><li>                                         P_SALARY IN NUMBER,  </li><li>                                         P_COUNT  OUT NUMBER) IS  </li><li>  V_SALARY NUMBER := P_SALARY;  </li><li>BEGIN  </li><li>  IF V_SALARY IS NULL THEN  </li><li>    V_SALARY := 0;  </li><li>  END IF;  </li><li>  IF P_USERID IS NULL THEN  </li><li>    SELECT COUNT(*)  </li><li>      INTO P_COUNT  </li><li>      FROM TMP_MICHAEL T  </li><li>     WHERE T.SALARY &gt;= V_SALARY;  </li><li>  ELSE  </li><li>    SELECT COUNT(*)  </li><li>      INTO P_COUNT  </li><li>      FROM TMP_MICHAEL T  </li><li>     WHERE T.SALARY &gt;= V_SALARY  </li><li>       AND T.USER_ID LIKE '%' || P_USERID || '%';  </li><li>  END IF;  </li><li>  DBMS_OUTPUT.PUT_LINE('v_count=:' || P_COUNT);  </li><li>END TEST_MICHAEL;  </li></ol></div><p>  调用程序如下：</p><div><div>Java代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [4].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>/** </li><li>    * 测试调用存储过程：返回值是简单值非列表 </li><li>    * @blog http://sjsky.iteye.com </li><li>    * @author Michael </li><li>    * @throws Exception </li><li>    */  </li><li>   public static void testProcOutSimple() throws Exception {  </li><li>       System.out.println(&quot;-------  start 测试调用存储过程：返回值是简单值非列表&quot;);  </li><li>       Connection conn = null;  </li><li>       CallableStatement stmt = null;  </li><li>       try {  </li><li>           Class.forName(DB_DRIVER);  </li><li>           conn = DriverManager.getConnection(DB_CONNECTION, DB_NAME, DB_PWd);  </li><li>  </li><li>           stmt = conn.prepareCall(&quot;{call TEST_MICHAEL(?,?,?)}&quot;);  </li><li>  </li><li>           stmt.setString(1, &quot;&quot;);  </li><li>           stmt.setDouble(2, 3000);  </li><li>  </li><li>           // out 注册的index 和取值时要对应  </li><li>           stmt.registerOutParameter(3, Types.INTEGER);  </li><li>           stmt.execute();  </li><li>  </li><li>           // getXxx(index)中的index 需要和上面registerOutParameter的index对应  </li><li>           int i = stmt.getInt(3);  </li><li>           System.out.println(&quot;符号条件的查询结果 count := &quot; + i);  </li><li>           System.out.println(&quot;-------  Test End.&quot;);  </li><li>       } catch (Exception e) {  </li><li>           e.printStackTrace(System.out);  </li><li>       } finally {  </li><li>           if (null != stmt) {  </li><li>               stmt.close();  </li><li>           }  </li><li>           if (null != conn) {  </li><li>               conn.close();  </li><li>           }  </li><li>       }  </li><li>   }  </li></ol></div><p>   <span style="color: #ff0000;">测试程序就是查询薪水3000以上人员的数量</span> ，运行结果如下：</p><div>------- start 测试调用存储过程：返回值是简单值非列表<br/>
符号条件的查询结果 count := 4<br/>
------- Test End.</div><p> </p><p><span style="color: rgb(0, 0, 255);">[三]、既有输入IN参数，也有输出OUT参数，输出是列表</span></p><p>  <span style="color: #ff0000;">首先需要创建PACKAGE TEST_PKG_CURSOR</span> 的SQL如下：</p><div><div>Sql代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [5].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>CREATE OR REPLACE PACKAGE TEST_PKG_CURSOR IS  </li><li>  </li><li>  -- Author  : MICHAEL  http://sjsky.iteye.com  </li><li>  TYPE TEST_CURSOR IS REF CURSOR;  </li><li>  </li><li>END TEST_PKG_CURSOR;  </li></ol></div><p><span style="color: #ff0000;">再创建存储过程 TEST_P_OUTRS</span> 的SQL如下：</p><div><div>Sql代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [6].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>CREATE OR REPLACE PROCEDURE TEST_P_OUTRS(P_SALARY IN NUMBER,  </li><li>                                         P_OUTRS  OUT TEST_PKG_CURSOR.TEST_CURSOR) IS  </li><li>  V_SALARY NUMBER := P_SALARY;  </li><li>BEGIN  </li><li>  IF P_SALARY IS NULL THEN  </li><li>    V_SALARY := 0;  </li><li>  END IF;  </li><li>  OPEN P_OUTRS FOR  </li><li>    SELECT * FROM TMP_MICHAEL T WHERE T.SALARY &gt; V_SALARY;  </li><li>END TEST_P_OUTRS;  </li></ol></div><p> 调用存储过程的代码如下：</p><div><div>Java代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [7].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>/** </li><li>    * 测试调用存储过程：有返回值且返回值为列表的 </li><li>    * @blog http://sjsky.iteye.com </li><li>    * @author Michael </li><li>    * @throws Exception </li><li>    */  </li><li>   public static void testProcOutRs() throws Exception {  </li><li>       System.out.println(&quot;-------  start 测试调用存储过程：有返回值且返回值为列表的&quot;);  </li><li>       Connection conn = null;  </li><li>       CallableStatement stmt = null;  </li><li>       ResultSet rs = null;  </li><li>       try {  </li><li>           Class.forName(DB_DRIVER);  </li><li>           conn = DriverManager.getConnection(DB_CONNECTION, DB_NAME, DB_PWd);  </li><li>  </li><li>           stmt = conn.prepareCall(&quot;{call TEST_P_OUTRS(?,?)}&quot;);  </li><li>  </li><li>           stmt.setDouble(1, 3000);  </li><li>           stmt.registerOutParameter(2, OracleTypes.CURSOR);  </li><li>           stmt.execute();  </li><li>  </li><li>           // getXxx(index)中的index 需要和上面registerOutParameter的index对应  </li><li>           rs = (ResultSet) stmt.getObject(2);  </li><li>           // 获取列名及类型  </li><li>           int colunmCount = rs.getMetaData().getColumnCount();  </li><li>           String[] colNameArr = new String[colunmCount];  </li><li>           String[] colTypeArr = new String[colunmCount];  </li><li>           for (int i = 0; i &lt; colunmCount; i++) {  </li><li>               colNameArr[i] = rs.getMetaData().getColumnName(i + 1);  </li><li>               colTypeArr[i] = rs.getMetaData().getColumnTypeName(i + 1);  </li><li>               System.out.print(colNameArr[i] + &quot;(&quot; + colTypeArr[i] + &quot;)&quot;  </li><li>                       + &quot; | &quot;);  </li><li>           }  </li><li>           System.out.println();  </li><li>           while (rs.next()) {  </li><li>               StringBuffer sb = new StringBuffer();  </li><li>               for (int i = 0; i &lt; colunmCount; i++) {  </li><li>                   sb.append(rs.getString(i + 1) + &quot; | &quot;);  </li><li>               }  </li><li>               System.out.println(sb);  </li><li>           }  </li><li>           System.out.println(&quot;------- Test Proc Out is ResultSet end. &quot;);  </li><li>  </li><li>       } catch (Exception e) {  </li><li>           e.printStackTrace(System.out);  </li><li>       } finally {  </li><li>           if (null != rs) {  </li><li>               rs.close();  </li><li>           }  </li><li>           if (null != stmt) {  </li><li>               stmt.close();  </li><li>           }  </li><li>           if (null != conn) {  </li><li>               conn.close();  </li><li>           }  </li><li>       }  </li><li>   }  </li></ol></div><p> 运行结果如下:</p><div>------- start 测试调用存储过程：有返回值且返回值为列表的<br/>
USER_ID(VARCHAR2) | USER_NAME(VARCHAR2) | SALARY(NUMBER) | OTHER_INFO(VARCHAR2) |<br/>
michael | Michael | 5000 | null |<br/>
zhangsan | 张三 | 10000 | null |<br/>
aoi_sola | 苍井空 | 99999.99 | null |<br/>
jdbc | JDBC | 8000 | http://sjsky.iteye.com |<br/>
------- Test Proc Out is ResultSet end.</div>
 
<p><span style="color: rgb(0, 0, 255);">[四]、输入输出参数是同一个（IN OUT）</span></p><p> </p><p><span style="color: #ff0000;">创建存储过程TEST_P_INOUT</span> 的SQL如下：</p><div><div>Sql代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [8].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>CREATE OR REPLACE PROCEDURE TEST_P_INOUT(P_USERID IN VARCHAR2,  </li><li>                                         P_NUM    IN OUT NUMBER) IS  </li><li>  V_COUNT  NUMBER;  </li><li>  V_SALARY NUMBER := P_NUM;  </li><li>BEGIN  </li><li>  IF V_SALARY IS NULL THEN  </li><li>    V_SALARY := 0;  </li><li>  END IF;  </li><li>  </li><li>  SELECT COUNT(*)  </li><li>    INTO V_COUNT  </li><li>    FROM TMP_MICHAEL  </li><li>   WHERE USER_ID LIKE '%' || P_USERID || '%'  </li><li>     AND SALARY &gt;= V_SALARY;  </li><li>  P_NUM := V_COUNT;  </li><li>END TEST_P_INOUT;  </li></ol></div><p> 调用存储过程的代码：</p><div><div>Java代码  <a title="收藏这段代码"><img src="jdbc的调用存储过程？_files/Image [9].png" type="image/png" alt="收藏代码" style="cursor: default;cursor: default;cursor: default;"/></a></div><ol start="1"><li>/** </li><li>     * 测试调用存储过程： INOUT同一个参数： </li><li>     * @blog http://sjsky.iteye.com </li><li>     * @author Michael </li><li>     * @throws Exception </li><li>     */  </li><li>    public static void testProcInOut() throws Exception {  </li><li>        System.out.println(&quot;-------  start 测试调用存储过程：INOUT同一个参数&quot;);  </li><li>        Connection conn = null;  </li><li>        CallableStatement stmt = null;  </li><li>        try {  </li><li>            Class.forName(DB_DRIVER);  </li><li>            conn = DriverManager.getConnection(DB_CONNECTION, DB_NAME, DB_PWd);  </li><li>  </li><li>            stmt = conn.prepareCall(&quot;{call TEST_P_INOUT(?,?)}&quot;);  </li><li>  </li><li>            stmt.setString(1, &quot;michael&quot;);  </li><li>            stmt.setDouble(2, 3000);  </li><li>  </li><li>            // 注意此次注册out 的index 和上面的in 参数index 相同  </li><li>            stmt.registerOutParameter(2, Types.INTEGER);  </li><li>            stmt.execute();  </li><li>  </li><li>            // getXxx(index)中的index 需要和上面registerOutParameter的index对应  </li><li>            int count = stmt.getInt(2);  </li><li>            System.out.println(&quot;符号条件的查询结果 count := &quot; + count);  </li><li>            System.out.println(&quot;-------  Test End.&quot;);  </li><li>        } catch (Exception e) {  </li><li>            e.printStackTrace(System.out);  </li><li>        } finally {  </li><li>            if (null != stmt) {  </li><li>                stmt.close();  </li><li>            }  </li><li>            if (null != conn) {  </li><li>                conn.close();  </li><li>            }  </li><li>        }  </li><li>    }  </li></ol></div><p> 运行结果如下：</p><div>------- start 测试调用存储过程：INOUT同一个参数<br/>
符号条件的查询结果 count := 1<br/>
------- Test End.</div></div></div>
</div></body></html> 