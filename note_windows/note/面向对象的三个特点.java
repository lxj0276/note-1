面向对象的三个特性：封装（Encapsulation），继承，多态。

封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式。之所以对外提供访问方式，就是因为可以在访问方式中加入判断语句，提高代码健壮性。
	
	好处：将变化隔离；便于使用；提高重用性；安全性。
	
	当一个类中没有定义构造函数时，系统会默认给该类加入一个空参数的构造函数。当自定义了构造函数时，系统就不在默认加构造函数。
	构造函数在对象一建立时就调用，给对象初始化，构造函数只运行一次；一般方法在对象调用时才执行，可以被对象多次调用。

	this代表他所在函数所属对象的引用。（即：哪个对象在调用this所在函数，this就代表哪个对象）
	this的两种应用：
			1、区分同名变量的情况：区分当定义类中功能时，该函数内部要用到调用该函数的对象时，这是用this来表示这个对象。
				但凡本类功能内部使用了本类对象，都用this表示。
			2、this语句：用于构造函数之间进行互相调用。
			this语句只能定义在构造函数的第一行，因为初始化要先执行。
		
继承：
	1、提高了代码的复用性。
	2、让类与类之间产生了关系。有了这个关系才有了多态的特性。
	注意:不能为了简化代码而继承，必须是类与类之间的所属关系才可以继承。 所属关系即为 is a .
	
	java中只支持单继承，不支持多继承，因为多继承容易带来安全隐患，当多个父类中定义了相同的功能，当功能内容不同时，子类对象不确定要运行哪一个。
		java支持多层继承，亦一个继承体系。
		如何使用一个继承体系中的功能？想要使用体系，先查阅体系父类的描述，因为父类中定义的是该体系中共性功能。
		想了解共享功能，就可以知道该体系的基本功能。那么这个体系就可以基本使用了。 
		
		简单的说：查阅父类功能，创建子类对象使用。
	
	如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量，用this；子类要访问父类中的同名变量，用super.
	
	覆盖：
		1、子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败。
		2、静态只能覆盖静态（静态先加载）。
	重载：函数的名字相同，参数列表相同。
	重写：子父类方法要一模一样。
	
	子父类的构造函数：
		在堆子类对象进行初始化时，父类的构造函数也会运行，并且会先运行，因为子类的构造函数默认第一行有一条隐士的语句super();
		super会访问父类中空参数的构造函数，而且子类中所有的构造函数默认第一行都是super().
		子类一定要访问父类中的构造函数，如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。
		super语句一定要定义在子类构造函数的第一行。
		子类的实例化过程：子类的所有构造函数，默认都会访问父类中空参数的构造函数。
		当父类中没有空参数的构造函数时，子类必须手动通过super或者this语句形式来指定要访问的构造函数。

多态：		
	多态的体现：父类的引用或接口的引用指向了自己的子类对象；父类的引用也可以接受自己的子类对象。
	多态的前提：必须是类于类之间的关系；比如继承，或者实现。通常会有覆盖操作。
	多态的好处：提高了程序的扩展性。
	多态的弊端：访问有局限性，是只能访问父类中具备的方法，不可以访问子类中特有的方法。
	
	在多态中，非静态成员函数的特点(父子类)：
		在编译时期:参阅引用型变量所属的类中是否有调用的方法。如果有编译通过，没有，失败。
		在运行时期：参阅对象所属的类中是否有调用的方法。
		简单说：成员函数在多态调用时，编译看左边，运行看右边。
		
	在多态中，成员变量和静态成员函数特点：
		无论编译运行都参考左边（引用型变量所属的类）。因为静态方法不所属于对象，类名调用即可，所以引用还在，找的就是引用型类调用的的方法。
		用绑定的思维理解即：静态方法加载时就已经和类绑定了。而非静态成员函数则是动态绑定（与对象绑定），对象可变，对象是谁就运行谁的。。